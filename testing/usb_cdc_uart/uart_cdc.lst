
uart_cdc.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
   0:	15c0006f          	j	15c <handle_reset>
   4:	00000000          	.word	0x00000000
   8:	00000222          	.word	0x00000222
   c:	000001d6          	.word	0x000001d6
	...
  30:	000001d6          	.word	0x000001d6
  34:	00000000          	.word	0x00000000
  38:	000001d6          	.word	0x000001d6
  3c:	00000000          	.word	0x00000000
  40:	000001d6          	.word	0x000001d6
  44:	000001d6          	.word	0x000001d6
  48:	000001d6          	.word	0x000001d6
  4c:	000001d6          	.word	0x000001d6
  50:	000007f0          	.word	0x000007f0
  54:	000001d6          	.word	0x000001d6
  58:	000001d6          	.word	0x000001d6
  5c:	000001d6          	.word	0x000001d6
  60:	000001d6          	.word	0x000001d6
  64:	000004c8          	.word	0x000004c8
  68:	000001d6          	.word	0x000001d6
  6c:	000001d6          	.word	0x000001d6
  70:	000001d6          	.word	0x000001d6
  74:	000001d6          	.word	0x000001d6
  78:	000001d6          	.word	0x000001d6
  7c:	000001d6          	.word	0x000001d6
  80:	000003de          	.word	0x000003de
  84:	000001d6          	.word	0x000001d6
  88:	000001d6          	.word	0x000001d6
  8c:	000001d6          	.word	0x000001d6
  90:	000001d6          	.word	0x000001d6
  94:	000001d6          	.word	0x000001d6
  98:	000001d6          	.word	0x000001d6
  9c:	0000                	unimp
	...

Disassembly of section .text:

000000a0 <PrintN>:
  a0:	e00007b7          	lui	a5,0xe0000
  a4:	0f478793          	addi	a5,a5,244 # e00000f4 <__global_pointer$+0xbffff8f4>
  a8:	4398                	lw	a4,0(a5)
  aa:	08077713          	andi	a4,a4,128
  ae:	ff6d                	bnez	a4,a8 <PrintN+0x8>
  b0:	78302737          	lui	a4,0x78302
  b4:	08870713          	addi	a4,a4,136 # 78302088 <__global_pointer$+0x58301888>
  b8:	e00006b7          	lui	a3,0xe0000
  bc:	c398                	sw	a4,0(a5)
  be:	0f468693          	addi	a3,a3,244 # e00000f4 <__global_pointer$+0xbffff8f4>
  c2:	4771                	li	a4,28
  c4:	45a5                	li	a1,9
  c6:	5671                	li	a2,-4
  c8:	429c                	lw	a5,0(a3)
  ca:	0807f793          	andi	a5,a5,128
  ce:	ffed                	bnez	a5,c8 <PrintN+0x28>
  d0:	00e55333          	srl	t1,a0,a4
  d4:	00f37313          	andi	t1,t1,15
  d8:	0065b7b3          	sltu	a5,a1,t1
  dc:	40f007b3          	neg	a5,a5
  e0:	0277f793          	andi	a5,a5,39
  e4:	03078793          	addi	a5,a5,48
  e8:	979a                	add	a5,a5,t1
  ea:	07a2                	slli	a5,a5,0x8
  ec:	0857e793          	ori	a5,a5,133
  f0:	c29c                	sw	a5,0(a3)
  f2:	1771                	addi	a4,a4,-4
  f4:	fcc71ae3          	bne	a4,a2,c8 <PrintN+0x28>
  f8:	8082                	ret

000000fa <start_tx_dma>:
    NVIC_EnableIRQ(USART1_IRQn);
}

static void start_tx_dma(void)
{
    if (tx_active || tx_head == tx_tail) return;
  fa:	8161c783          	lbu	a5,-2026(gp) # 20000016 <tx_active>
  fe:	eba9                	bnez	a5,150 <start_tx_dma+0x56>
 100:	8141d583          	lhu	a1,-2028(gp) # 20000014 <tx_head>
 104:	8121d703          	lhu	a4,-2030(gp) # 20000012 <tx_tail>
 108:	04e58463          	beq	a1,a4,150 <start_tx_dma+0x56>
    uint16_t len = (tx_head > tx_tail)
 10c:	8141d583          	lhu	a1,-2028(gp) # 20000014 <tx_head>
 110:	8121d703          	lhu	a4,-2030(gp) # 20000012 <tx_tail>
 114:	02b77f63          	bgeu	a4,a1,152 <start_tx_dma+0x58>
        ? (tx_head - tx_tail)
 118:	8141d783          	lhu	a5,-2028(gp) # 20000014 <tx_head>
 11c:	8121d703          	lhu	a4,-2030(gp) # 20000012 <tx_tail>
    uint16_t len = (tx_head > tx_tail)
 120:	8f99                	sub	a5,a5,a4
 122:	07c2                	slli	a5,a5,0x10
 124:	83c1                	srli	a5,a5,0x10
        : (UART_BUFFER_SIZE - tx_tail);
    tx_last_len = len;
 126:	80f19823          	sh	a5,-2032(gp) # 20000010 <tx_last_len>
    DMA1_Channel4->CFGR &= ~DMA_CFGR1_EN;
 12a:	40020737          	lui	a4,0x40020
 12e:	436c                	lw	a1,68(a4)
 130:	99f9                	andi	a1,a1,-2
 132:	c36c                	sw	a1,68(a4)
    DMA1_Channel4->CNTR  = len;
 134:	c73c                	sw	a5,72(a4)
    DMA1_Channel4->MADDR = (uint32_t)&tx_buffer[tx_tail];
 136:	8121d683          	lhu	a3,-2030(gp) # 20000012 <tx_tail>
 13a:	c6818793          	addi	a5,gp,-920 # 20000468 <tx_buffer>
 13e:	97b6                	add	a5,a5,a3
 140:	cb3c                	sw	a5,80(a4)
    DMA1_Channel4->CFGR |= DMA_CFGR1_EN;
 142:	437c                	lw	a5,68(a4)
 144:	0017e793          	ori	a5,a5,1
 148:	c37c                	sw	a5,68(a4)
    tx_active = 1;
 14a:	4785                	li	a5,1
 14c:	80f18b23          	sb	a5,-2026(gp) # 20000016 <tx_active>
}
 150:	8082                	ret
        : (UART_BUFFER_SIZE - tx_tail);
 152:	8121d703          	lhu	a4,-2030(gp) # 20000012 <tx_tail>
    uint16_t len = (tx_head > tx_tail)
 156:	10000793          	li	a5,256
 15a:	b7d9                	j	120 <start_tx_dma+0x26>

0000015c <handle_reset>:
 15c:	20000197          	auipc	gp,0x20000
 160:	6a418193          	addi	gp,gp,1700 # 20000800 <__global_pointer$>
 164:	00018113          	mv	sp,gp
 168:	08000513          	li	a0,128
 16c:	30051073          	csrw	mstatus,a0
 170:	468d                	li	a3,3
 172:	00000517          	auipc	a0,0x0
 176:	e8e50513          	addi	a0,a0,-370 # 0 <InterruptVector>
 17a:	8d55                	or	a0,a0,a3
 17c:	30551073          	csrw	mtvec,a0
 180:	20000517          	auipc	a0,0x20000
 184:	e8050513          	addi	a0,a0,-384 # 20000000 <eventhead>
 188:	d6818593          	addi	a1,gp,-664 # 20000568 <_ebss>
 18c:	4601                	li	a2,0
 18e:	00b55663          	bge	a0,a1,19a <handle_reset+0x3e>
 192:	c110                	sw	a2,0(a0)
 194:	0511                	addi	a0,a0,4
 196:	feb54ee3          	blt	a0,a1,192 <handle_reset+0x36>
 19a:	00001517          	auipc	a0,0x1
 19e:	b2250513          	addi	a0,a0,-1246 # cbc <_data_lma>
 1a2:	20000597          	auipc	a1,0x20000
 1a6:	e5e58593          	addi	a1,a1,-418 # 20000000 <eventhead>
 1aa:	20000617          	auipc	a2,0x20000
 1ae:	e5660613          	addi	a2,a2,-426 # 20000000 <eventhead>
 1b2:	00c58863          	beq	a1,a2,1c2 <handle_reset+0x66>
 1b6:	4114                	lw	a3,0(a0)
 1b8:	c194                	sw	a3,0(a1)
 1ba:	0511                	addi	a0,a0,4
 1bc:	0591                	addi	a1,a1,4
 1be:	fec59ae3          	bne	a1,a2,1b2 <handle_reset+0x56>
 1c2:	e000f7b7          	lui	a5,0xe000f
 1c6:	4715                	li	a4,5
 1c8:	c398                	sw	a4,0(a5)
 1ca:	2a000793          	li	a5,672
 1ce:	34179073          	csrw	mepc,a5
 1d2:	30200073          	mret

000001d6 <ADC1_2_IRQHandler>:

// Return the Machine Exception Program Register (MEPC)
static inline uint32_t __get_MEPC(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mepc" : "=r"(result));
 1d6:	34102573          	csrr	a0,mepc
void DefaultIRQHandler( void )
{
#if FUNCONF_DEBUG_HARDFAULT && ( FUNCONF_USE_DEBUGPRINTF || FUNCONF_USE_UARTPRINTF )
	//This is kind of like a crash handler.
	//printf( "DEAD MSTATUS:%08x MTVAL:%08x MCAUSE:%08x MEPC:%08x\n", (int)__get_MSTATUS(), (int)__get_MTVAL(), (int)__get_MCAUSE(), (int)__get_MEPC() );
	PrintN( __get_MEPC() ); // "addr2line -e debugprintfdemo.elf 0x000007e6" ---> debugprintfdemo.c:45
 1da:	35d9                	jal	a0 <PrintN>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0, mstatus": "=r"(result) );
 1dc:	30002573          	csrr	a0,mstatus
	PrintN( __get_MSTATUS() );
 1e0:	35c1                	jal	a0 <PrintN>

// Return the Machine Trap Value Register (MTVAL)
static inline uint32_t __get_MTVAL(void)
{
	uint32_t result;
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mtval" : "=r" (result) );
 1e2:	34302573          	csrr	a0,mtval
	PrintN( __get_MTVAL() );
 1e6:	3d6d                	jal	a0 <PrintN>
	__ASM volatile( ADD_ARCH_ZICSR "csrr %0," "mcause": "=r"(result));
 1e8:	34202573          	csrr	a0,mcause
	PrintN( __get_MCAUSE() );
 1ec:	3d55                	jal	a0 <PrintN>
#if FUNCONF_USE_DEBUGPRINTF
	while( (*DMDATA0) & 0x80 );
 1ee:	e00007b7          	lui	a5,0xe0000
 1f2:	0f478793          	addi	a5,a5,244 # e00000f4 <__global_pointer$+0xbffff8f4>
 1f6:	4398                	lw	a4,0(a5)
 1f8:	08077713          	andi	a4,a4,128
 1fc:	ff6d                	bnez	a4,1f6 <ADC1_2_IRQHandler+0x20>
	*DMDATA0 = 0x0a85;
 1fe:	6705                	lui	a4,0x1
 200:	a8570713          	addi	a4,a4,-1403 # a85 <handle_se0_keepalive+0x5f>
 204:	c398                	sw	a4,0(a5)
	while( (*DMDATA0) & 0x80 );
 206:	e00007b7          	lui	a5,0xe0000
 20a:	0f478793          	addi	a5,a5,244 # e00000f4 <__global_pointer$+0xbffff8f4>
 20e:	4398                	lw	a4,0(a5)
 210:	08077713          	andi	a4,a4,128
 214:	ff6d                	bnez	a4,20e <ADC1_2_IRQHandler+0x38>
	*DMDATA0 = 0xaaaaaa83;
 216:	aaaab737          	lui	a4,0xaaaab
 21a:	a8370713          	addi	a4,a4,-1405 # aaaaaa83 <__global_pointer$+0x8aaaa283>
 21e:	c398                	sw	a4,0(a5)
	putchar( '\n' );
#endif
#endif
	//printf( "DEAD MSTATUS:%08x MTVAL:%08x MCAUSE:%08x MEPC:%08x\n", (int)__get_MSTATUS(), (int)__get_MTVAL(), (int)__get_MCAUSE(), (int)__get_MEPC() );
	// Infinite Loop
	asm volatile( "1: j 1b" );
 220:	a001                	j	220 <ADC1_2_IRQHandler+0x4a>

00000222 <NMI_Handler>:
 * 			The sys clock is switched to HSI.
 * 			Clears the CSSF flag in RCC->INTR
 */
void NMI_RCC_CSS_IRQHandler( void )
{
	RCC->INTR |= RCC_CSSC;	// clear the clock security int flag
 222:	40021737          	lui	a4,0x40021
 226:	471c                	lw	a5,8(a4)
 228:	008006b7          	lui	a3,0x800
 22c:	8fd5                	or	a5,a5,a3
 22e:	c71c                	sw	a5,8(a4)

00000230 <memcpy>:
 230:	4781                	li	a5,0
 232:	00f61363          	bne	a2,a5,238 <memcpy+0x8>
 236:	8082                	ret
 238:	00f58733          	add	a4,a1,a5
 23c:	00074683          	lbu	a3,0(a4) # 40021000 <__global_pointer$+0x20020800>
 240:	00f50733          	add	a4,a0,a5
 244:	0785                	addi	a5,a5,1
 246:	00d70023          	sb	a3,0(a4)
 24a:	b7e5                	j	232 <memcpy+0x2>

0000024c <SystemInit>:
 24c:	400227b7          	lui	a5,0x40022
 250:	4705                	li	a4,1
 252:	c398                	sw	a4,0(a5)
 254:	400217b7          	lui	a5,0x40021
 258:	01080737          	lui	a4,0x1080
 25c:	0007a223          	sw	zero,4(a5) # 40021004 <__global_pointer$+0x20020804>
 260:	08170713          	addi	a4,a4,129 # 1080081 <rv003usb.c.084415bf+0x107cdcf>
 264:	c398                	sw	a4,0(a5)
 266:	009f0737          	lui	a4,0x9f0
 26a:	c798                	sw	a4,8(a5)
 26c:	4398                	lw	a4,0(a5)
 26e:	00671693          	slli	a3,a4,0x6
 272:	fe06dde3          	bgez	a3,26c <SystemInit+0x20>
 276:	43d8                	lw	a4,4(a5)
 278:	400216b7          	lui	a3,0x40021
 27c:	9b71                	andi	a4,a4,-4
 27e:	00276713          	ori	a4,a4,2
 282:	c3d8                	sw	a4,4(a5)
 284:	4721                	li	a4,8
 286:	42dc                	lw	a5,4(a3)
 288:	8bb1                	andi	a5,a5,12
 28a:	fee79ee3          	bne	a5,a4,286 <SystemInit+0x3a>
 28e:	e00007b7          	lui	a5,0xe0000
 292:	0e07ac23          	sw	zero,248(a5) # e00000f8 <__global_pointer$+0xbffff8f8>
 296:	08000713          	li	a4,128
 29a:	0ee7aa23          	sw	a4,244(a5)
 29e:	8082                	ret

000002a0 <main>:
{
    e->opaque = 0;
}

int main(void)
{
 2a0:	1171                	addi	sp,sp,-4
 2a2:	c006                	sw	ra,0(sp)
    SystemInit();
 2a4:	3765                	jal	24c <SystemInit>
    RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_USART1;
 2a6:	400216b7          	lui	a3,0x40021
 2aa:	4e9c                	lw	a5,24(a3)
 2ac:	6711                	lui	a4,0x4
 2ae:	02070713          	addi	a4,a4,32 # 4020 <rv003usb.c.084415bf+0xd6e>
    funPinMode(PD5, GPIO_CFGLR_OUT_10Mhz_AF_PP);
 2b2:	40011637          	lui	a2,0x40011
    RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_USART1;
 2b6:	8fd9                	or	a5,a5,a4
 2b8:	ce9c                	sw	a5,24(a3)
    funPinMode(PD5, GPIO_CFGLR_OUT_10Mhz_AF_PP);
 2ba:	40060793          	addi	a5,a2,1024 # 40011400 <__global_pointer$+0x20010c00>
 2be:	4398                	lw	a4,0(a5)
 2c0:	ff1005b7          	lui	a1,0xff100
 2c4:	15fd                	addi	a1,a1,-1 # ff0fffff <__global_pointer$+0xdf0ff7ff>
 2c6:	8f6d                	and	a4,a4,a1
 2c8:	009005b7          	lui	a1,0x900
 2cc:	8f4d                	or	a4,a4,a1
 2ce:	c398                	sw	a4,0(a5)
    GPIO_pinMode(GPIOv_from_PORT_PIN(GPIO_port_D, 6), GPIO_pinMode_I_floating, GPIO_Speed_10MHz);
 2d0:	4398                	lw	a4,0(a5)
 2d2:	f10005b7          	lui	a1,0xf1000
 2d6:	15fd                	addi	a1,a1,-1 # f0ffffff <__global_pointer$+0xd0fff7ff>
 2d8:	8f6d                	and	a4,a4,a1
 2da:	c398                	sw	a4,0(a5)
 2dc:	4398                	lw	a4,0(a5)
 2de:	040005b7          	lui	a1,0x4000
    DMA1_Channel4->CFGR  = DMA_CFGR1_MINC | DMA_CFGR1_DIR | DMA_CFGR1_TCIE;
 2e2:	09200513          	li	a0,146
    GPIO_pinMode(GPIOv_from_PORT_PIN(GPIO_port_D, 6), GPIO_pinMode_I_floating, GPIO_Speed_10MHz);
 2e6:	8f4d                	or	a4,a4,a1
 2e8:	c398                	sw	a4,0(a5)
    USART1->CTLR1 = USART_WordLength_8b | USART_Parity_No | USART_Mode_Tx | USART_Mode_Rx;
 2ea:	400147b7          	lui	a5,0x40014
 2ee:	4731                	li	a4,12
 2f0:	80e79623          	sh	a4,-2036(a5) # 4001380c <__global_pointer$+0x2001300c>
    USART1->CTLR2 = USART_StopBits_1;
 2f4:	80079823          	sh	zero,-2032(a5)
    USART1->CTLR3 = USART_DMAReq_Tx | USART_DMAReq_Rx;
 2f8:	0c000713          	li	a4,192
 2fc:	80e79a23          	sh	a4,-2028(a5)
    USART1->BRR   = (FUNCONF_SYSTEM_CORE_CLOCK + UART_BR/2)/UART_BR;
 300:	1a100713          	li	a4,417
 304:	80e79423          	sh	a4,-2040(a5)
    USART1->CTLR1 |= CTLR1_UE_Set;
 308:	80c7d703          	lhu	a4,-2036(a5)
 30c:	6589                	lui	a1,0x2
 30e:	8f4d                	or	a4,a4,a1
 310:	80e79623          	sh	a4,-2036(a5)
    RCC->AHBPCENR |= RCC_AHBPeriph_SRAM | RCC_AHBPeriph_DMA1;
 314:	4ad8                	lw	a4,20(a3)
 316:	00576713          	ori	a4,a4,5
 31a:	cad8                	sw	a4,20(a3)
    DMA1_Channel4->CFGR &= ~DMA_CFGR1_EN;
 31c:	40020737          	lui	a4,0x40020
 320:	436c                	lw	a1,68(a4)
 322:	99f9                	andi	a1,a1,-2
 324:	c36c                	sw	a1,68(a4)
    DMA1_Channel4->PADDR = (uint32_t)&USART1->DATAR;
 326:	80478593          	addi	a1,a5,-2044
 32a:	c76c                	sw	a1,76(a4)
    DMA1_Channel4->CFGR  = DMA_CFGR1_MINC | DMA_CFGR1_DIR | DMA_CFGR1_TCIE;
 32c:	c368                	sw	a0,68(a4)
	NVIC->IENR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));
 32e:	e000e537          	lui	a0,0xe000e
 332:	02000737          	lui	a4,0x2000
 336:	10e52023          	sw	a4,256(a0) # e000e100 <__global_pointer$+0xc000d900>
    RCC->AHBPCENR |= RCC_AHBPeriph_SRAM | RCC_AHBPeriph_DMA1;
 33a:	4ad8                	lw	a4,20(a3)
 33c:	00576713          	ori	a4,a4,5
 340:	cad8                	sw	a4,20(a3)
    DMA1_Channel5->CFGR &= ~DMA_CFGR1_EN;
 342:	40020737          	lui	a4,0x40020
 346:	05872303          	lw	t1,88(a4) # 40020058 <__global_pointer$+0x2001f858>
 34a:	ffe37313          	andi	t1,t1,-2
 34e:	04672c23          	sw	t1,88(a4)
    DMA1_Channel5->PADDR = (uint32_t)&USART1->DATAR;
 352:	d32c                	sw	a1,96(a4)
    DMA1_Channel5->MADDR = (uint32_t)rx_buffer;
 354:	b6818593          	addi	a1,gp,-1176 # 20000368 <rx_buffer>
 358:	d36c                	sw	a1,100(a4)
    DMA1_Channel5->CNTR  = UART_BUFFER_SIZE;
 35a:	10000593          	li	a1,256
 35e:	cf6c                	sw	a1,92(a4)
    DMA1_Channel5->CFGR  = DMA_CFGR1_MINC | DMA_CFGR1_CIRC;
 360:	0a000593          	li	a1,160
 364:	cf2c                	sw	a1,88(a4)
    DMA1_Channel5->CFGR |= DMA_CFGR1_EN;
 366:	4f2c                	lw	a1,88(a4)
 368:	0015e593          	ori	a1,a1,1
 36c:	cf2c                	sw	a1,88(a4)
    USART1->CTLR1 |= USART_CTLR1_IDLEIE;
 36e:	80c7d703          	lhu	a4,-2036(a5)
 372:	01076713          	ori	a4,a4,16
 376:	80e79623          	sh	a4,-2036(a5)
 37a:	4785                	li	a5,1
 37c:	10f52223          	sw	a5,260(a0)
void usb_setup()
{
	rv003usb_internal_data.se0_windup = 0;

	// Enable GPIOs, TIMERs
	RCC->APB2PCENR |= LOCAL_EXP( RCC_APB2Periph_GPIO, USB_PORT ) | RCC_APB2Periph_AFIO;
 380:	4e9c                	lw	a5,24(a3)
	}
#endif

	// GPIO Setup
	LOCAL_EXP( GPIO, USB_PORT )->CFGLR = 
		( LOCAL_EXP( GPIO, USB_PORT )->CFGLR & 
 382:	ff001737          	lui	a4,0xff001
 386:	177d                	addi	a4,a4,-1 # ff000fff <__global_pointer$+0xdf0007ff>
	RCC->APB2PCENR |= LOCAL_EXP( RCC_APB2Periph_GPIO, USB_PORT ) | RCC_APB2Periph_AFIO;
 388:	0117e793          	ori	a5,a5,17
 38c:	ce9c                	sw	a5,24(a3)
		( LOCAL_EXP( GPIO, USB_PORT )->CFGLR & 
 38e:	421c                	lw	a5,0(a2)
 390:	8ff9                	and	a5,a5,a4
			) )) )
		 |
#ifdef USB_PIN_DPU
		(GPIO_Speed_50MHz | GPIO_CNF_OUT_PP)<<(4*USB_PIN_DPU) |
#endif
		(GPIO_Speed_In | GPIO_CNF_IN_PUPD)<<(4*USB_PIN_DP) | 
 392:	00388737          	lui	a4,0x388
 396:	8fd9                	or	a5,a5,a4
	LOCAL_EXP( GPIO, USB_PORT )->CFGLR = 
 398:	c21c                	sw	a5,0(a2)
		(GPIO_Speed_In | GPIO_CNF_IN_PUPD)<<(4*USB_PIN_DM);

	// Configure USB_PIN_DM (D-) as an interrupt on falling edge.
	AFIO->EXTICR = LOCAL_EXP(GPIO_PortSourceGPIO,USB_PORT)<<(USB_PIN_DM*2); // Configure EXTI interrupt for USB_PIN_DM
 39a:	20000713          	li	a4,512
 39e:	400107b7          	lui	a5,0x40010
 3a2:	c798                	sw	a4,8(a5)
	EXTI->INTENR = 1<<USB_PIN_DM; // Enable EXTI interrupt
 3a4:	40078793          	addi	a5,a5,1024 # 40010400 <__global_pointer$+0x2000fc00>
 3a8:	4741                	li	a4,16
 3aa:	c398                	sw	a4,0(a5)
	EXTI->FTENR = 1<<USB_PIN_DM;  // Enable falling edge trigger for USB_PIN_DM (D-)
 3ac:	c7d8                	sw	a4,12(a5)

#ifdef USB_PIN_DPU
	// This drives USB_PIN_DPU (D- Pull-Up) high, which will tell the host that we are going on-bus.
	LOCAL_EXP(GPIO,USB_PORT)->BSHR = 1<<USB_PIN_DPU;
 3ae:	02000793          	li	a5,32
 3b2:	ca1c                	sw	a5,16(a2)
 3b4:	001007b7          	lui	a5,0x100
 3b8:	10f52023          	sw	a5,256(a0)
	int event = eventtail;
 3bc:	20000737          	lui	a4,0x20000
	if( eventhead == event ) return 0;
 3c0:	20000637          	lui	a2,0x20000
	int event = eventtail;
 3c4:	00174683          	lbu	a3,1(a4) # 20000001 <eventtail>
	if( eventhead == event ) return 0;
 3c8:	00064583          	lbu	a1,0(a2) # 20000000 <eventhead>
	int event = eventtail;
 3cc:	0ff6f793          	zext.b	a5,a3
	if( eventhead == event ) return 0;
 3d0:	feb68ae3          	beq	a3,a1,3c4 <main+0x124>
	eventtail = ( event + 1 ) & (NUMUEVENTS-1);
 3d4:	0785                	addi	a5,a5,1 # 100001 <rv003usb.c.084415bf+0xfcd4f>
 3d6:	8bfd                	andi	a5,a5,31
 3d8:	00f700a3          	sb	a5,1(a4)
	return &events[event*4];
 3dc:	b7e5                	j	3c4 <main+0x124>

000003de <USART1_IRQHandler>:
{
 3de:	7179                	addi	sp,sp,-48
 3e0:	c03e                	sw	a5,0(sp)
    if (USART1->STATR & USART_STATR_IDLE) {
 3e2:	400147b7          	lui	a5,0x40014
{
 3e6:	c23a                	sw	a4,4(sp)
    if (USART1->STATR & USART_STATR_IDLE) {
 3e8:	8007d703          	lhu	a4,-2048(a5) # 40013800 <__global_pointer$+0x20013000>
{
 3ec:	d606                	sw	ra,44(sp)
 3ee:	d416                	sw	t0,40(sp)
 3f0:	d21a                	sw	t1,36(sp)
 3f2:	d01e                	sw	t2,32(sp)
 3f4:	ce22                	sw	s0,28(sp)
 3f6:	cc26                	sw	s1,24(sp)
 3f8:	ca2a                	sw	a0,20(sp)
 3fa:	c82e                	sw	a1,16(sp)
 3fc:	c632                	sw	a2,12(sp)
 3fe:	c436                	sw	a3,8(sp)
    if (USART1->STATR & USART_STATR_IDLE) {
 400:	8b41                	andi	a4,a4,16
 402:	cb35                	beqz	a4,476 <USART1_IRQHandler+0x98>
 404:	80078793          	addi	a5,a5,-2048
        (void)USART1->STATR;
 408:	0007d703          	lhu	a4,0(a5)
        (void)USART1->DATAR;
 40c:	0047d783          	lhu	a5,4(a5)
        rx_write_pos = (UART_BUFFER_SIZE - DMA1_Channel5->CNTR) % UART_BUFFER_SIZE;
 410:	400207b7          	lui	a5,0x40020
 414:	05878793          	addi	a5,a5,88 # 40020058 <__global_pointer$+0x2001f858>
 418:	43dc                	lw	a5,4(a5)
 41a:	40f007b3          	neg	a5,a5
 41e:	0ff7f793          	zext.b	a5,a5
 422:	80f19723          	sh	a5,-2034(gp) # 2000000e <rx_write_pos>
        if (rx_write_pos != rx_read_pos) {
 426:	80e1d683          	lhu	a3,-2034(gp) # 2000000e <rx_write_pos>
 42a:	80c1d703          	lhu	a4,-2036(gp) # 2000000c <rx_read_pos>
 42e:	04e68463          	beq	a3,a4,476 <USART1_IRQHandler+0x98>
            uint8_t *src = &rx_buffer[rx_read_pos];
 432:	80c1d683          	lhu	a3,-2036(gp) # 2000000c <rx_read_pos>
 436:	b6818593          	addi	a1,gp,-1176 # 20000368 <rx_buffer>
            if (rx_write_pos > rx_read_pos) {
 43a:	80e1d603          	lhu	a2,-2034(gp) # 2000000e <rx_write_pos>
            uint8_t *src = &rx_buffer[rx_read_pos];
 43e:	95b6                	add	a1,a1,a3
            if (rx_write_pos > rx_read_pos) {
 440:	80c1d683          	lhu	a3,-2036(gp) # 2000000c <rx_read_pos>
 444:	04c6f863          	bgeu	a3,a2,494 <USART1_IRQHandler+0xb6>
                len = rx_write_pos - rx_read_pos;
 448:	80e1d403          	lhu	s0,-2034(gp) # 2000000e <rx_write_pos>
 44c:	80c1d703          	lhu	a4,-2036(gp) # 2000000c <rx_read_pos>
                memcpy((void*)usb_tx_buffer, src, len);
 450:	a6818513          	addi	a0,gp,-1432 # 20000268 <usb_tx_buffer>
                len = rx_write_pos - rx_read_pos;
 454:	8c19                	sub	s0,s0,a4
 456:	0442                	slli	s0,s0,0x10
 458:	8041                	srli	s0,s0,0x10
                memcpy((void*)usb_tx_buffer, src, len);
 45a:	8622                	mv	a2,s0
 45c:	3bd1                	jal	230 <memcpy>
            rx_read_pos   = rx_write_pos;
 45e:	80e1d703          	lhu	a4,-2034(gp) # 2000000e <rx_write_pos>
 462:	0742                	slli	a4,a4,0x10
 464:	8341                	srli	a4,a4,0x10
 466:	80e19623          	sh	a4,-2036(gp) # 2000000c <rx_read_pos>
            size_to_send  = len;
 46a:	8081a423          	sw	s0,-2040(gp) # 20000008 <size_to_send>
            send_index    = 0;
 46e:	200007b7          	lui	a5,0x20000
 472:	0007a223          	sw	zero,4(a5) # 20000004 <send_index>
}
 476:	4472                	lw	s0,28(sp)
 478:	50b2                	lw	ra,44(sp)
 47a:	52a2                	lw	t0,40(sp)
 47c:	5312                	lw	t1,36(sp)
 47e:	5382                	lw	t2,32(sp)
 480:	44e2                	lw	s1,24(sp)
 482:	4552                	lw	a0,20(sp)
 484:	45c2                	lw	a1,16(sp)
 486:	4632                	lw	a2,12(sp)
 488:	46a2                	lw	a3,8(sp)
 48a:	4712                	lw	a4,4(sp)
 48c:	4782                	lw	a5,0(sp)
 48e:	6145                	addi	sp,sp,48
 490:	30200073          	mret
                uint16_t first = UART_BUFFER_SIZE - rx_read_pos;
 494:	80c1d683          	lhu	a3,-2036(gp) # 2000000c <rx_read_pos>
 498:	10000413          	li	s0,256
                memcpy((void*)usb_tx_buffer, src, first);
 49c:	a6818513          	addi	a0,gp,-1432 # 20000268 <usb_tx_buffer>
                uint16_t first = UART_BUFFER_SIZE - rx_read_pos;
 4a0:	8c15                	sub	s0,s0,a3
 4a2:	0442                	slli	s0,s0,0x10
 4a4:	8041                	srli	s0,s0,0x10
                memcpy((void*)usb_tx_buffer, src, first);
 4a6:	8622                	mv	a2,s0
 4a8:	3361                	jal	230 <memcpy>
                memcpy((void*)(usb_tx_buffer + first), rx_buffer, rx_write_pos);
 4aa:	80e1d603          	lhu	a2,-2034(gp) # 2000000e <rx_write_pos>
 4ae:	a6818693          	addi	a3,gp,-1432 # 20000268 <usb_tx_buffer>
 4b2:	b6818593          	addi	a1,gp,-1176 # 20000368 <rx_buffer>
 4b6:	00868533          	add	a0,a3,s0
 4ba:	3b9d                	jal	230 <memcpy>
                len = first + rx_write_pos;
 4bc:	80e1d703          	lhu	a4,-2034(gp) # 2000000e <rx_write_pos>
 4c0:	943a                	add	s0,s0,a4
 4c2:	0442                	slli	s0,s0,0x10
 4c4:	8041                	srli	s0,s0,0x10
 4c6:	bf61                	j	45e <USART1_IRQHandler+0x80>

000004c8 <DMA1_Channel4_IRQHandler>:
{
 4c8:	fd810113          	addi	sp,sp,-40
 4cc:	c23a                	sw	a4,4(sp)
    DMA1->INTFCR |= DMA_CTCIF4;
 4ce:	40020737          	lui	a4,0x40020
{
 4d2:	c03e                	sw	a5,0(sp)
    DMA1->INTFCR |= DMA_CTCIF4;
 4d4:	435c                	lw	a5,4(a4)
{
 4d6:	c436                	sw	a3,8(sp)
    DMA1->INTFCR |= DMA_CTCIF4;
 4d8:	6689                	lui	a3,0x2
{
 4da:	d206                	sw	ra,36(sp)
 4dc:	d016                	sw	t0,32(sp)
 4de:	ce1a                	sw	t1,28(sp)
 4e0:	cc1e                	sw	t2,24(sp)
 4e2:	ca2a                	sw	a0,20(sp)
 4e4:	c82e                	sw	a1,16(sp)
 4e6:	c632                	sw	a2,12(sp)
    DMA1->INTFCR |= DMA_CTCIF4;
 4e8:	8fd5                	or	a5,a5,a3
 4ea:	c35c                	sw	a5,4(a4)
    tx_tail    = (tx_tail + tx_last_len) % UART_BUFFER_SIZE;
 4ec:	8121d783          	lhu	a5,-2030(gp) # 20000012 <tx_tail>
 4f0:	8101d683          	lhu	a3,-2032(gp) # 20000010 <tx_last_len>
 4f4:	97b6                	add	a5,a5,a3
 4f6:	0ff7f793          	zext.b	a5,a5
 4fa:	80f19923          	sh	a5,-2030(gp) # 20000012 <tx_tail>
    tx_active  = 0;
 4fe:	80018b23          	sb	zero,-2026(gp) # 20000016 <tx_active>
    start_tx_dma();
 502:	3ee5                	jal	fa <start_tx_dma>
}
 504:	5092                	lw	ra,36(sp)
 506:	5282                	lw	t0,32(sp)
 508:	4372                	lw	t1,28(sp)
 50a:	43e2                	lw	t2,24(sp)
 50c:	4552                	lw	a0,20(sp)
 50e:	45c2                	lw	a1,16(sp)
 510:	4632                	lw	a2,12(sp)
 512:	46a2                	lw	a3,8(sp)
 514:	4712                	lw	a4,4(sp)
 516:	4782                	lw	a5,0(sp)
 518:	02810113          	addi	sp,sp,40
 51c:	30200073          	mret

00000520 <usb_pid_handle_in>:
	NVIC_EnableIRQ( EXTI7_0_IRQn );
}


void usb_pid_handle_in( uint32_t addr, uint8_t * data, uint32_t endp, uint32_t unused, struct rv003usb_internal * ist )
{
 520:	1131                	addi	sp,sp,-20
 522:	c622                	sw	s0,12(sp)
 524:	c426                	sw	s1,8(sp)
 526:	c806                	sw	ra,16(sp)
 528:	00461793          	slli	a5,a2,0x4
	ist->current_endpoint = endp;
 52c:	00c70023          	sb	a2,0(a4) # 40020000 <__global_pointer$+0x2001f800>
 530:	97ba                	add	a5,a5,a4
	struct usb_endpoint * e = &ist->eps[endp];

	int tosend = 0;
	uint8_t * sendnow;
	int sendtok = e->toggle_in?0b01001011:0b11000011;
 532:	0117c503          	lbu	a0,17(a5)



#if RV003USB_USE_REBOOT_FEATURE_REPORT
	if( ist->reboot_armed == 2 )
 536:	00374683          	lbu	a3,3(a4)
{
 53a:	84ba                	mv	s1,a4
	int sendtok = e->toggle_in?0b01001011:0b11000011;
 53c:	00153513          	seqz	a0,a0
 540:	40a00533          	neg	a0,a0
 544:	07857513          	andi	a0,a0,120
	if( ist->reboot_armed == 2 )
 548:	4709                	li	a4,2
{
 54a:	8432                	mv	s0,a2
	int sendtok = e->toggle_in?0b01001011:0b11000011;
 54c:	04b50513          	addi	a0,a0,75
	if( ist->reboot_armed == 2 )
 550:	04e69563          	bne	a3,a4,59a <usb_pid_handle_in+0x7a>
 554:	c23e                	sw	a5,4(sp)
	{
		usb_send_empty( sendtok );
 556:	c02a                	sw	a0,0(sp)
 558:	2b05                	jal	a88 <usb_send_empty>

		// Initiate boot into bootloader
		FLASH->BOOT_MODEKEYR = FLASH_KEY1;
 55a:	456706b7          	lui	a3,0x45670
 55e:	40022737          	lui	a4,0x40022
 562:	12368693          	addi	a3,a3,291 # 45670123 <__global_pointer$+0x2566f923>
 566:	d714                	sw	a3,40(a4)
		FLASH->BOOT_MODEKEYR = FLASH_KEY2;
 568:	cdef96b7          	lui	a3,0xcdef9
 56c:	9ab68693          	addi	a3,a3,-1621 # cdef89ab <__global_pointer$+0xadef81ab>
 570:	d714                	sw	a3,40(a4)
		FLASH->STATR = 1<<14; // 1<<14 is zero, so, boot bootloader code. Unset for user code.
 572:	6691                	lui	a3,0x4
 574:	c754                	sw	a3,12(a4)
		FLASH->CTLR = CR_LOCK_Set;
 576:	08000693          	li	a3,128
 57a:	cb14                	sw	a3,16(a4)
		RCC->RSTSCKR |= 0x1000000;
 57c:	400216b7          	lui	a3,0x40021
 580:	52d8                	lw	a4,36(a3)
 582:	01000637          	lui	a2,0x1000
		PFIC->SCTLR = 1<<31;
 586:	4792                	lw	a5,4(sp)
		RCC->RSTSCKR |= 0x1000000;
 588:	8f51                	or	a4,a4,a2
		PFIC->SCTLR = 1<<31;
 58a:	4502                	lw	a0,0(sp)
		RCC->RSTSCKR |= 0x1000000;
 58c:	d2d8                	sw	a4,36(a3)
		PFIC->SCTLR = 1<<31;
 58e:	e000f737          	lui	a4,0xe000f
 592:	800006b7          	lui	a3,0x80000
 596:	d0d72823          	sw	a3,-752(a4) # e000ed10 <__global_pointer$+0xc000e510>
	}
#endif

#if RV003USB_HANDLE_IN_REQUEST
	if( e->custom || endp )
 59a:	0137c783          	lbu	a5,19(a5)
 59e:	e391                	bnez	a5,5a2 <usb_pid_handle_in+0x82>
 5a0:	cc29                	beqz	s0,5fa <usb_pid_handle_in+0xda>
    if (ep == 3) {
 5a2:	478d                	li	a5,3
 5a4:	06f41863          	bne	s0,a5,614 <usb_pid_handle_in+0xf4>
        if (send_index < size_to_send) {
 5a8:	200004b7          	lui	s1,0x20000
 5ac:	0044a683          	lw	a3,4(s1) # 20000004 <send_index>
 5b0:	8081a703          	lw	a4,-2040(gp) # 20000008 <size_to_send>
 5b4:	06e6d063          	bge	a3,a4,614 <usb_pid_handle_in+0xf4>
            int chunk = (size_to_send - send_index > 8) ? 8 : size_to_send - send_index;
 5b8:	8081a703          	lw	a4,-2040(gp) # 20000008 <size_to_send>
 5bc:	0044a683          	lw	a3,4(s1)
 5c0:	4421                	li	s0,8
 5c2:	8f15                	sub	a4,a4,a3
 5c4:	00e44763          	blt	s0,a4,5d2 <usb_pid_handle_in+0xb2>
 5c8:	8081a403          	lw	s0,-2040(gp) # 20000008 <size_to_send>
 5cc:	0044a783          	lw	a5,4(s1)
 5d0:	8c1d                	sub	s0,s0,a5
            usb_send_data((uint8_t*)(usb_tx_buffer + send_index), chunk, 0, tok);
 5d2:	0044a703          	lw	a4,4(s1)
 5d6:	a6818793          	addi	a5,gp,-1432 # 20000268 <usb_tx_buffer>
 5da:	86aa                	mv	a3,a0
 5dc:	85a2                	mv	a1,s0
 5de:	00e78533          	add	a0,a5,a4
 5e2:	4601                	li	a2,0
 5e4:	294d                	jal	a96 <usb_send_data>
            send_index += chunk;
 5e6:	0044a783          	lw	a5,4(s1)
	}
	else
	{
		usb_send_data( sendnow, tosend, 0, sendtok );
	}
}
 5ea:	40c2                	lw	ra,16(sp)
 5ec:	943e                	add	s0,s0,a5
 5ee:	0084a223          	sw	s0,4(s1)
 5f2:	4432                	lw	s0,12(sp)
 5f4:	44a2                	lw	s1,8(sp)
 5f6:	0151                	addi	sp,sp,20
 5f8:	8082                	ret
	int offset = (e->count)<<3;
 5fa:	0104c783          	lbu	a5,16(s1)
	sendnow = tsend + offset;
 5fe:	4cd8                	lw	a4,28(s1)
	tosend = (int)e->max_len - offset;
 600:	0144d583          	lhu	a1,20(s1)
	int offset = (e->count)<<3;
 604:	078e                	slli	a5,a5,0x3
	tosend = (int)e->max_len - offset;
 606:	8d9d                	sub	a1,a1,a5
	sendnow = tsend + offset;
 608:	97ba                	add	a5,a5,a4
	if( tosend > ENDPOINT0_SIZE ) tosend = ENDPOINT0_SIZE;
 60a:	4721                	li	a4,8
 60c:	00b74963          	blt	a4,a1,61e <usb_pid_handle_in+0xfe>
	if( tosend <= 0 )
 610:	00b04863          	bgtz	a1,620 <usb_pid_handle_in+0x100>
}
 614:	4432                	lw	s0,12(sp)
 616:	40c2                	lw	ra,16(sp)
 618:	44a2                	lw	s1,8(sp)
 61a:	0151                	addi	sp,sp,20
		usb_send_empty( sendtok );
 61c:	a1b5                	j	a88 <usb_send_empty>
	if( tosend > ENDPOINT0_SIZE ) tosend = ENDPOINT0_SIZE;
 61e:	85ba                	mv	a1,a4
}
 620:	4432                	lw	s0,12(sp)
 622:	40c2                	lw	ra,16(sp)
 624:	44a2                	lw	s1,8(sp)
		usb_send_data( sendnow, tosend, 0, sendtok );
 626:	86aa                	mv	a3,a0
 628:	4601                	li	a2,0
 62a:	853e                	mv	a0,a5
}
 62c:	0151                	addi	sp,sp,20
		usb_send_data( sendnow, tosend, 0, sendtok );
 62e:	a1a5                	j	a96 <usb_send_data>

00000630 <usb_pid_handle_data>:
}

void usb_pid_handle_data( uint32_t this_token, uint8_t * data, uint32_t which_data, uint32_t length, struct rv003usb_internal * ist )
{
	//Received data from host.
	int epno = ist->current_endpoint;
 630:	00074783          	lbu	a5,0(a4)

	length -= 3;
	uint8_t * data_in = __builtin_assume_aligned( data, 4 );

	// Already received this packet.
	if( e->toggle_out != which_data )
 634:	00479513          	slli	a0,a5,0x4
 638:	953a                	add	a0,a0,a4
 63a:	01254303          	lbu	t1,18(a0)
 63e:	04c31b63          	bne	t1,a2,694 <usb_pid_handle_data+0x64>
	{
		goto just_ack;
	}

	e->toggle_out = !e->toggle_out;
 642:	00133313          	seqz	t1,t1
 646:	00650923          	sb	t1,18(a0)
	length -= 3;
 64a:	16f5                	addi	a3,a3,-3 # 7ffffffd <__global_pointer$+0x5ffff7fd>


#if RV003USB_HANDLE_USER_DATA || RV003USB_USE_REBOOT_FEATURE_REPORT || RV003USB_USB_TERMINAL
	if( epno || ( !ist->setup_request && length > 3 )  )
 64c:	e799                	bnez	a5,65a <usb_pid_handle_data+0x2a>
 64e:	00274603          	lbu	a2,2(a4)
 652:	ee49                	bnez	a2,6ec <usb_pid_handle_data+0xbc>
 654:	460d                	li	a2,3
 656:	02d67f63          	bgeu	a2,a3,694 <usb_pid_handle_data+0x64>
	{
#if RV003USB_USE_REBOOT_FEATURE_REPORT
		if( ist->reboot_armed )
 65a:	00374603          	lbu	a2,3(a4)
 65e:	c239                	beqz	a2,6a4 <usb_pid_handle_data+0x74>
		{
			uint32_t * base = __builtin_assume_aligned( data_in, 4 );
			if( epno == 0 && base[0] == 0xaa3412fd && (base[1] & 0x00ffffff) == 0x00ddccbb )
 660:	e3a1                	bnez	a5,6a0 <usb_pid_handle_data+0x70>
 662:	4194                	lw	a3,0(a1)
 664:	aa3417b7          	lui	a5,0xaa341
 668:	2fd78793          	addi	a5,a5,765 # aa3412fd <__global_pointer$+0x8a340afd>
 66c:	02f69263          	bne	a3,a5,690 <usb_pid_handle_data+0x60>
 670:	41dc                	lw	a5,4(a1)
 672:	00ddd6b7          	lui	a3,0xddd
 676:	cbb68693          	addi	a3,a3,-837 # ddccbb <rv003usb.c.084415bf+0xdd9a09>
 67a:	07a2                	slli	a5,a5,0x8
 67c:	83a1                	srli	a5,a5,0x8
 67e:	00d79963          	bne	a5,a3,690 <usb_pid_handle_data+0x60>
			{
				e->count = 7;
 682:	479d                	li	a5,7
 684:	00f70823          	sb	a5,16(a4)
				ist->reboot_armed = 2;
 688:	4789                	li	a5,2

		if( reqShl == (0x0921>>1) )
		{
			// Class request (Will be writing)  This is hid_send_feature_report
#if RV003USB_USE_REBOOT_FEATURE_REPORT
			if( wvi == 0x000003fd ) ist->reboot_armed = 1;
 68a:	00f701a3          	sb	a5,3(a4)
 68e:	a019                	j	694 <usb_pid_handle_data+0x64>
				ist->reboot_armed = 0;
 690:	000701a3          	sb	zero,3(a4)
		}
	}
just_ack:
	{
		//Got the right data.  Acknowledge.
		usb_send_data( 0, 0, 2, 0xD2 ); // Send ACK
 694:	0d200693          	li	a3,210
 698:	4609                	li	a2,2
 69a:	4581                	li	a1,0
 69c:	4501                	li	a0,0
 69e:	a025                	j	6c6 <usb_pid_handle_data+0x96>
				ist->reboot_armed = 0;
 6a0:	000701a3          	sb	zero,3(a4)
    if (ep != 2 || len == 0) return;
 6a4:	4709                	li	a4,2
 6a6:	fee797e3          	bne	a5,a4,694 <usb_pid_handle_data+0x64>
 6aa:	d6ed                	beqz	a3,694 <usb_pid_handle_data+0x64>
{
 6ac:	1171                	addi	sp,sp,-4
 6ae:	c006                	sw	ra,0(sp)
    for (int i = 0; i < len; i++)
 6b0:	4701                	li	a4,0
 6b2:	00d74b63          	blt	a4,a3,6c8 <usb_pid_handle_data+0x98>
    start_tx_dma();
 6b6:	3491                	jal	fa <start_tx_dma>
	}
	return;
}
 6b8:	4082                	lw	ra,0(sp)
		usb_send_data( 0, 0, 2, 0xD2 ); // Send ACK
 6ba:	0d200693          	li	a3,210
 6be:	4609                	li	a2,2
 6c0:	4581                	li	a1,0
 6c2:	4501                	li	a0,0
}
 6c4:	0111                	addi	sp,sp,4
		usb_send_data( 0, 0, 2, 0xD2 ); // Send ACK
 6c6:	aec1                	j	a96 <usb_send_data>
        tx_buffer[tx_head = (tx_head + 1) % UART_BUFFER_SIZE] = data[i];
 6c8:	8141d783          	lhu	a5,-2028(gp) # 20000014 <tx_head>
 6cc:	00e58633          	add	a2,a1,a4
 6d0:	00064283          	lbu	t0,0(a2) # 1000000 <rv003usb.c.084415bf+0xffcd4e>
 6d4:	0785                	addi	a5,a5,1
 6d6:	0ff7f793          	zext.b	a5,a5
 6da:	c6818613          	addi	a2,gp,-920 # 20000468 <tx_buffer>
 6de:	80f19a23          	sh	a5,-2028(gp) # 20000014 <tx_head>
 6e2:	97b2                	add	a5,a5,a2
 6e4:	00578023          	sb	t0,0(a5)
    for (int i = 0; i < len; i++)
 6e8:	0705                	addi	a4,a4,1
 6ea:	b7e1                	j	6b2 <usb_pid_handle_data+0x82>
		uint32_t wvi = s->lValueLSBIndexMSB;
 6ec:	0045d683          	lhu	a3,4(a1) # 2004 <ch32fun.c.e1c3a22b+0xa46>
 6f0:	0025d783          	lhu	a5,2(a1)
		uint32_t wLength = s->wLength;
 6f4:	0065d503          	lhu	a0,6(a1)
		uint32_t wvi = s->lValueLSBIndexMSB;
 6f8:	06c2                	slli	a3,a3,0x10
		e->count = 0;
 6fa:	00070823          	sb	zero,16(a4)
		e->custom = 0;
 6fe:	000709a3          	sb	zero,19(a4)
		ist->setup_request = 0;
 702:	00070123          	sb	zero,2(a4)
		uint32_t wvi = s->lValueLSBIndexMSB;
 706:	8edd                	or	a3,a3,a5
		uint32_t reqShl = s->wRequestTypeLSBRequestMSB >> 1;
 708:	0005d783          	lhu	a5,0(a1)
		e->opaque = 0;
 70c:	00072e23          	sw	zero,28(a4)
		e->max_len = 0;
 710:	00071a23          	sh	zero,20(a4)
		uint32_t reqShl = s->wRequestTypeLSBRequestMSB >> 1;
 714:	8385                	srli	a5,a5,0x1
		if( reqShl == (0x0921>>1) )
 716:	49000613          	li	a2,1168
 71a:	00c79863          	bne	a5,a2,72a <usb_pid_handle_data+0xfa>
			if( wvi == 0x000003fd ) ist->reboot_armed = 1;
 71e:	3fd00793          	li	a5,1021
 722:	f6f699e3          	bne	a3,a5,694 <usb_pid_handle_data+0x64>
 726:	4785                	li	a5,1
 728:	b78d                	j	68a <usb_pid_handle_data+0x5a>
		if( reqShl == (0x0680>>1) ) // GET_DESCRIPTOR = 6 (msb)
 72a:	34000613          	li	a2,832
 72e:	06c79a63          	bne	a5,a2,7a2 <usb_pid_handle_data+0x172>
 732:	6785                	lui	a5,0x1
 734:	c7478793          	addi	a5,a5,-908 # c74 <descriptor_list>
 738:	04878593          	addi	a1,a5,72
					e->max_len = (swLen < elLen)?swLen:elLen;
 73c:	832a                	mv	t1,a0
				if( dl->lIndexValue == wvi )
 73e:	4390                	lw	a2,0(a5)
 740:	00d61f63          	bne	a2,a3,75e <usb_pid_handle_data+0x12e>
					e->opaque = (uint8_t*)dl->addr;
 744:	43d0                	lw	a2,4(a5)
 746:	cf50                	sw	a2,28(a4)
					uint16_t elLen = dl->length;
 748:	0087c603          	lbu	a2,8(a5)
					e->max_len = (swLen < elLen)?swLen:elLen;
 74c:	01061293          	slli	t0,a2,0x10
 750:	0102d293          	srli	t0,t0,0x10
 754:	00557363          	bgeu	a0,t0,75a <usb_pid_handle_data+0x12a>
 758:	861a                	mv	a2,t1
 75a:	00c71a23          	sh	a2,20(a4)
			for( i = 0; i < DESCRIPTOR_LIST_ENTRIES; i++ )
 75e:	07b1                	addi	a5,a5,12
 760:	fcb79fe3          	bne	a5,a1,73e <usb_pid_handle_data+0x10e>
			if( !e->max_len ) LogUEvent( 1234, dl->lIndexValue, dl->length, 0 );
 764:	01475783          	lhu	a5,20(a4)
 768:	f795                	bnez	a5,694 <usb_pid_handle_data+0x64>
	int event = eventhead;
 76a:	20000637          	lui	a2,0x20000
 76e:	00064783          	lbu	a5,0(a2) # 20000000 <eventhead>
	uint32_t * e = &events[event*4];
 772:	200006b7          	lui	a3,0x20000
 776:	06868693          	addi	a3,a3,104 # 20000068 <events>
 77a:	00479713          	slli	a4,a5,0x4
 77e:	9736                	add	a4,a4,a3
	e[0] = a;
 780:	4d200693          	li	a3,1234
 784:	c314                	sw	a3,0(a4)
	e[1] = b;
 786:	040906b7          	lui	a3,0x4090
 78a:	30368693          	addi	a3,a3,771 # 4090303 <rv003usb.c.084415bf+0x408d051>
	eventhead = (event + 1) & (NUMUEVENTS-1);
 78e:	0785                	addi	a5,a5,1
	e[1] = b;
 790:	c354                	sw	a3,4(a4)
	eventhead = (event + 1) & (NUMUEVENTS-1);
 792:	8bfd                	andi	a5,a5,31
	e[2] = c;
 794:	46a9                	li	a3,10
 796:	c714                	sw	a3,8(a4)
	e[3] = d;
 798:	00072623          	sw	zero,12(a4)
	eventhead = (event + 1) & (NUMUEVENTS-1);
 79c:	00f60023          	sb	a5,0(a2)
}
 7a0:	bdd5                	j	694 <usb_pid_handle_data+0x64>
		else if( reqShl == (0x0500>>1) ) // SET_ADDRESS = 0x05
 7a2:	28000613          	li	a2,640
 7a6:	eec797e3          	bne	a5,a2,694 <usb_pid_handle_data+0x64>
			ist->my_address = wvi;
 7aa:	00d700a3          	sb	a3,1(a4)
 7ae:	b5dd                	j	694 <usb_pid_handle_data+0x64>

000007b0 <usb_pid_handle_ack>:
#else

void usb_pid_handle_ack( uint32_t dummy, uint8_t * data, uint32_t dummy1, uint32_t dummy2, struct rv003usb_internal * ist  )
{
	struct usb_endpoint * e = &ist->eps[ist->current_endpoint];
	e->toggle_in = !e->toggle_in;
 7b0:	00074783          	lbu	a5,0(a4)
 7b4:	0792                	slli	a5,a5,0x4
 7b6:	973e                	add	a4,a4,a5
 7b8:	01174783          	lbu	a5,17(a4)
 7bc:	0017b793          	seqz	a5,a5
 7c0:	00f708a3          	sb	a5,17(a4)
	e->count++;
 7c4:	01074783          	lbu	a5,16(a4)
 7c8:	0785                	addi	a5,a5,1
 7ca:	00f70823          	sb	a5,16(a4)
}
 7ce:	8082                	ret

000007d0 <usb_pid_handle_setup>:

//Received a setup for a specific endpoint.
void usb_pid_handle_setup( uint32_t addr, uint8_t * data, uint32_t endp, uint32_t unused, struct rv003usb_internal * ist )
{
	struct usb_endpoint * e = &ist->eps[endp];
	ist->current_endpoint = endp;
 7d0:	00c70023          	sb	a2,0(a4)
	ist->setup_request = 1;
 7d4:	4785                	li	a5,1
 7d6:	0612                	slli	a2,a2,0x4
 7d8:	00f70123          	sb	a5,2(a4)
	e->toggle_in = 1;
 7dc:	9732                	add	a4,a4,a2
	e->toggle_out = 0;
	e->count = 0;
 7de:	10000793          	li	a5,256
 7e2:	00f71823          	sh	a5,16(a4)
	e->toggle_out = 0;
 7e6:	00070923          	sb	zero,18(a4)
	e->opaque = 0;
 7ea:	00072e23          	sw	zero,28(a4)
}
 7ee:	8082                	ret

000007f0 <EXTI7_0_IRQHandler>:
.section .text.vector_handler
.global EXTI7_0_IRQHandler

.balign 4
EXTI7_0_IRQHandler:
	addi	sp,sp,-80
 7f0:	715d                	addi	sp,sp,-80
	sw	a0, 0(sp)
 7f2:	c02a                	sw	a0,0(sp)
	sw	a5, 20(sp)
 7f4:	ca3e                	sw	a5,20(sp)
	la a5, USB_GPIO_BASE
 7f6:	400117b7          	lui	a5,0x40011
	c.lw a0, INDR_OFFSET(a5) // MUST check SE0 immediately.
 7fa:	4788                	lw	a0,8(a5)
	c.andi a0, USB_DMASK
 7fc:	8961                	andi	a0,a0,24

	sw	a1, 4(sp)
 7fe:	c22e                	sw	a1,4(sp)
	sw	a2, 8(sp)
 800:	c432                	sw	a2,8(sp)
	sw	a3, 12(sp)
 802:	c636                	sw	a3,12(sp)
	sw	a4, 16(sp)
 804:	c83a                	sw	a4,16(sp)
	sw	s1, 28(sp)
 806:	ce26                	sw	s1,28(sp)
	c.lw a2, 0(a1)
	c.andi a2, USB_DMASK
	c.beqz a2, another_interrupt_check
#endif

	SAVE_DEBUG_MARKER( 48 );
 808:	d812                	sw	tp,48(sp)
	DEBUG_TICK_SETUP
 80a:	40013237          	lui	tp,0x40013
 80e:	c5820213          	addi	tp,tp,-936 # 40012c58 <__global_pointer$+0x20012458>
	c.lw a1, INDR_OFFSET(a5)
 812:	478c                	lw	a1,8(a5)
	c.andi a1, USB_DMASK;
 814:	89e1                	andi	a1,a1,24

	// Finish jump to se0
	c.beqz a0, handle_se0_keepalive
 816:	20050863          	beqz	a0,a26 <handle_se0_keepalive>

	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 81a:	4788                	lw	a0,8(a5)
 81c:	8961                	andi	a0,a0,24
 81e:	02b51b63          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 822:	4788                	lw	a0,8(a5)
 824:	8961                	andi	a0,a0,24
 826:	02b51763          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 82a:	4788                	lw	a0,8(a5)
 82c:	8961                	andi	a0,a0,24
 82e:	02b51363          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 832:	4788                	lw	a0,8(a5)
 834:	8961                	andi	a0,a0,24
 836:	00b51f63          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 83a:	4788                	lw	a0,8(a5)
 83c:	8961                	andi	a0,a0,24
 83e:	00b51b63          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 842:	4788                	lw	a0,8(a5)
 844:	8961                	andi	a0,a0,24
 846:	00b51763          	bne	a0,a1,854 <syncout>
	c.lw a0, INDR_OFFSET(a5); c.andi a0, USB_DMASK; bne a0, a1, syncout
 84a:	4788                	lw	a0,8(a5)
 84c:	8961                	andi	a0,a0,24
 84e:	00b51363          	bne	a0,a1,854 <syncout>
	c.j syncout
 852:	a009                	j	854 <syncout>

00000854 <syncout>:
syncout:
	sw	s0, 24(sp)
 854:	cc22                	sw	s0,24(sp)
	li a2, 0
 856:	4601                	li	a2,0
	sw	t0, 32(sp)  // XXX NOTE: This is actually unused register - remove some day?
 858:	d016                	sw	t0,32(sp)
	sw	t1, 36(sp)
 85a:	d21a                	sw	t1,36(sp)

0000085c <preamble_loop>:
	
	// This is actually somewhat late.
	// The preamble loop should try to make it earlier.
.balign 4
preamble_loop:
	DEBUG_TICK_MARK
 85c:	00022023          	sw	zero,0(tp) # 0 <InterruptVector>
	c.lw a0, INDR_OFFSET(a5);
 860:	4788                	lw	a0,8(a5)
	c.andi a0, USB_DMASK;
 862:	8961                	andi	a0,a0,24
	c.beqz a0, done_usb_message // SE0 here?
 864:	18050763          	beqz	a0,9f2 <done_usb_message>
	c.xor a0, a1;
 868:	8d2d                	xor	a0,a0,a1
	c.xor a1, a0; // Recover a1.
 86a:	8da9                	xor	a1,a1,a0
	j 1f; 1: // 4 cycles?
 86c:	a009                	j	86e <preamble_loop+0x12>
	c.beqz a0, done_preamble
 86e:	c909                	beqz	a0,880 <done_preamble>
	j 1f; 1: // 4 cycles?
 870:	a009                	j	872 <preamble_loop+0x16>
	c.lw s0, INDR_OFFSET(a5);
 872:	4780                	lw	s0,8(a5)
	c.andi s0, USB_DMASK;
 874:	8861                	andi	s0,s0,24
	c.xor s0, a1
 876:	8c2d                	xor	s0,s0,a1

	// TRICKY: This helps retime the USB sync.
	// If s0 is nonzero, then it's changed (we're going too slow)
	c.bnez s0, 2f;  // This code takes 6 cycles or 8 cycles, depending.
 878:	e011                	bnez	s0,87c <preamble_loop+0x20>
	c.j 1f; 1:
 87a:	a009                	j	87c <preamble_loop+0x20>
	2:
	j preamble_loop // 4 cycles
 87c:	b7c5                	j	85c <preamble_loop>
 87e:	0001                	nop

00000880 <done_preamble>:
.balign 4
done_preamble:
	sw  t2, 40(sp)
 880:	d41e                	sw	t2,40(sp)
	sw  ra, 52(sp)
 882:	da06                	sw	ra,52(sp)
	// 16-byte temporary buffer at 56+sp

	// XXX TODO: Do one byte here to determine the header byte and from that set the CRC.
	c.li s1, 8
 884:	44a1                	li	s1,8

	// This is the first bit that matters.
	c.li s0, 6 // 1 runs.
 886:	4419                	li	s0,6

	c.nop; 
 888:	0001                	nop
 88a:	0001                	nop

0000088c <packet_type_loop>:
packet_type_loop:
	// Up here to delay loop a tad, and we need to execute them anyway.
	// TODO: Maybe we could further sync bits here instead of take up time?
	// I.e. can we do what we're doing above, here, and take less time, but sync
	// up when possible.
	li a3, 0xffff // Starting CRC of 0.   Because USB doesn't respect reverse CRCing.
 88c:	66c1                	lui	a3,0x10
 88e:	16fd                	addi	a3,a3,-1 # ffff <rv003usb.c.084415bf+0xcd4d>
	li a4, 0xa001
 890:	6729                	lui	a4,0xa
 892:	0705                	addi	a4,a4,1 # a001 <rv003usb.c.084415bf+0x6d4f>
	addi  t2, sp, DATA_PTR_OFFSET //rv003usb_internal_data
 894:	03f10393          	addi	t2,sp,63
	la  t0, 0x80
 898:	08000293          	li	t0,128
	c.nop
 89c:	0001                	nop
 89e:	0001                	nop

	DEBUG_TICK_MARK
 8a0:	00022023          	sw	zero,0(tp) # 0 <InterruptVector>
	c.lw a0, INDR_OFFSET(a5);
 8a4:	4788                	lw	a0,8(a5)
	c.andi a0, USB_DMASK;
 8a6:	8961                	andi	a0,a0,24
	c.beqz a0, done_usb_message // Not se0 complete, that can't happen here and be valid.
 8a8:	14050563          	beqz	a0,9f2 <done_usb_message>
	c.xor a0, a1;
 8ac:	8d2d                	xor	a0,a0,a1
	c.xor a1, a0; // Recover a1, for next cycle
 8ae:	8da9                	xor	a1,a1,a0

	// No CRC for the header.
	//c.srli a0, USB_PIN_DP
	//c.addi a0, 1 // 00 -> 1, 11 -> 100
	//c.andi a0, 1 // If 1, 1 if 0, 0
        c.nop
 8b0:	0001                	nop
        seqz a0, a0
 8b2:	00153513          	seqz	a0,a0

	// Write header into byte in reverse order, because we can.
	c.slli a2, 1
 8b6:	0606                	slli	a2,a2,0x1
	c.or a2, a0
 8b8:	8e49                	or	a2,a2,a0

	// Handle bit stuffing rules.
	c.addi a0, -1 // 0->0xffffffff 1->0
 8ba:	157d                	addi	a0,a0,-1
	c.or s0, a0
 8bc:	8c49                	or	s0,s0,a0
	c.andi s0, 7
 8be:	881d                	andi	s0,s0,7
	c.addi s0, -1
 8c0:	147d                	addi	s0,s0,-1
	c.addi s1, -1
 8c2:	14fd                	addi	s1,s1,-1
	c.bnez s1, packet_type_loop
 8c4:	f4e1                	bnez	s1,88c <packet_type_loop>
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////	

	// XXX Here, figure out CRC polynomial.

	li s1, (USB_BUFFER_SIZE*8) // # of bits we culd read.
 8c6:	06000493          	li	s1,96
	//
	// When we get here, packet type is loaded in A2.
	// If packet type is 0xXX01 or 0xXX11
	// the LSBs are the inverted packet type.
	// we can branch off of bit 2.
	andi a0, a2, 0x0c
 8ca:	00c67513          	andi	a0,a2,12

	// if a0 is 1 then it's DATA (full CRC) otherwise,
	// (0) for setup or PARTIAL CRC.
	// Careful:  This has to take a constant amount of time either way the branch goes.
	c.beqz a0, data_crc
 8ce:	c509                	beqz	a0,8d8 <data_crc>
	c.li a4, 0x14	
 8d0:	4751                	li	a4,20
	c.li a3, 0x1e
 8d2:	46f9                	li	a3,30
 8d4:	00000013          	.word	0x00000013

000008d8 <data_crc>:

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////	
.balign 4
is_end_of_byte:
	HANDLE_EOB_YES
 8d8:	00c38023          	sb	a2,0(t2)
 8dc:	00138393          	.word	0x00138393

000008e0 <bit_process>:
	// end-of-byte.
.balign 4
bit_process:
	// Debug blip
//	c.lw a4, INDR_OFFSET(a5);
	DEBUG_TICK_MARK
 8e0:	00022023          	sw	zero,0(tp) # 0 <InterruptVector>
	c.lw a0, INDR_OFFSET(a5);
 8e4:	4788                	lw	a0,8(a5)
	c.andi a0, USB_DMASK;
 8e6:	8961                	andi	a0,a0,24
	c.xor a0, a1;
 8e8:	8d2d                	xor	a0,a0,a1
#define HANDLE_NEXT_BYTE(is_end_of_byte, jumptype)  \
	c.addi s1, -1; \
	andi a0, s1, 7; /* s1 could be really really big */ \
	c.jumptype a0, is_end_of_byte /* 4 cycles for this section. (Checked) (Sometimes 5)? */ 

	c.beqz a0, handle_one_bit
 8ea:	c50d                	beqz	a0,914 <handle_one_bit>

000008ec <handle_zero_bit>:
handle_zero_bit:
	c.xor a1, a0; // Recover a1, for next cycle
 8ec:	8da9                	xor	a1,a1,a0
	// TODO: Do we have time to do time fixup here?
	// Can we resync time here?
	// If they are different, we need to sloowwww dowwwnnn
	// There is some free time.  Could do something interesting here!!!
	// I was thinking we could put the resync code here.
	c.j 1f; 1:  //Delay 4 cycles.
 8ee:	a009                	j	8f0 <handle_zero_bit+0x4>

	c.li s0, 6      // reset runs-of-one.
 8f0:	4419                	li	s0,6
	c.beqz a1, se0_complete
 8f2:	c9bd                	beqz	a1,968 <se0_complete>

	// Handle CRC (0 bit)  (From @Domkeykong)
	slli a0,a3,31 // Put a3s LSB into a0s MSB
 8f4:	01f69513          	slli	a0,a3,0x1f
	c.srai a0,31    // Copy MSB into all other bits
 8f8:	857d                	srai	a0,a0,0x1f
	c.srli a3,1
 8fa:	8285                	srli	a3,a3,0x1
	c.and  a0, a4
 8fc:	8d79                	and	a0,a0,a4
	c.xor  a3, a0
 8fe:	8ea9                	xor	a3,a3,a0

	c.srli a2, 1;  // shift a2 down by 1
 900:	8205                	srli	a2,a2,0x1
	HANDLE_NEXT_BYTE(is_end_of_byte, beqz)
 902:	14fd                	addi	s1,s1,-1
 904:	0074f513          	andi	a0,s1,7
 908:	d961                	beqz	a0,8d8 <data_crc>
	c.nop
 90a:	0001                	nop
	c.nop
 90c:	0001                	nop
	c.nop
 90e:	0001                	nop
	c.bnez s1, bit_process // + 4 cycles
 910:	f8e1                	bnez	s1,8e0 <bit_process>
	c.j done_usb_message
 912:	a0c5                	j	9f2 <done_usb_message>

00000914 <handle_one_bit>:


.balign 4
handle_one_bit:
	c.addi s0, -1; // Count # of runs of 1 (subtract 1)
 914:	147d                	addi	s0,s0,-1
	//HANDLE_CRC (1 bit)
	andi a0, a3, 1
 916:	0016f513          	andi	a0,a3,1
	c.addi a0, -1
 91a:	157d                	addi	a0,a0,-1
	c.and a0, a4
 91c:	8d79                	and	a0,a0,a4
	c.srli a3, 1
 91e:	8285                	srli	a3,a3,0x1
	c.xor a3, a0
 920:	8ea9                	xor	a3,a3,a0

	c.srli a2, 1;  // shift a2 down by 1
 922:	8205                	srli	a2,a2,0x1
	ori a2, a2, 0x80
 924:	08066613          	ori	a2,a2,128
	c.beqz s0, handle_bit_stuff;
 928:	c811                	beqz	s0,93c <handle_bit_stuff>

	HANDLE_NEXT_BYTE(is_end_of_byte, beqz)
 92a:	14fd                	addi	s1,s1,-1
 92c:	0074f513          	andi	a0,s1,7
 930:	d545                	beqz	a0,8d8 <data_crc>
	c.nop // Need extra delay here because we need more time if it's end-of-byte.
 932:	0001                	nop
	c.nop
 934:	0001                	nop
	c.nop
 936:	0001                	nop
	c.bnez s1, bit_process // + 4 cycles
 938:	f4c5                	bnez	s1,8e0 <bit_process>
	c.j done_usb_message
 93a:	a865                	j	9f2 <done_usb_message>

0000093c <handle_bit_stuff>:

handle_bit_stuff:
	// We want to wait a little bit, then read another byte, and make
	// sure everything is well, before heading back into the main loop
	// Debug blip
	HANDLE_NEXT_BYTE(not_is_end_of_byte_and_bit_stuffed, bnez)
 93c:	14fd                	addi	s1,s1,-1
 93e:	0074f513          	andi	a0,s1,7
 942:	e509                	bnez	a0,94c <not_is_end_of_byte_and_bit_stuffed>
	HANDLE_EOB_YES
 944:	00c38023          	sb	a2,0(t2)
 948:	00138393          	.word	0x00138393

0000094c <not_is_end_of_byte_and_bit_stuffed>:

not_is_end_of_byte_and_bit_stuffed:
        DEBUG_TICK_MARK
 94c:	00022023          	sw	zero,0(tp) # 0 <InterruptVector>
	c.lw a0, INDR_OFFSET(a5);
 950:	4788                	lw	a0,8(a5)
	c.andi a0, USB_DMASK;
 952:	8961                	andi	a0,a0,24
	c.beqz a0, se0_complete
 954:	c911                	beqz	a0,968 <se0_complete>
	c.xor a0, a1;
 956:	8d2d                	xor	a0,a0,a1
	c.xor a1, a0; // Recover a1, for next cycle.
 958:	8da9                	xor	a1,a1,a0

	// If A0 is a 0 then that's bad, we just did a bit stuff
        //   and A0 == 0 means there was no signal transition
	c.beqz a0, done_usb_message
 95a:	cd41                	beqz	a0,9f2 <done_usb_message>

        // Reset bit stuff, delay, then continue onto the next actual bit
	c.li s0, 6;
 95c:	4419                	li	s0,6

        c.nop;
 95e:	0001                	nop
	nx6p3delay( 2, a0 )
 960:	450d                	li	a0,3
 962:	157d                	addi	a0,a0,-1
 964:	fd7d                	bnez	a0,962 <not_is_end_of_byte_and_bit_stuffed+0x16>

	c.bnez s1, bit_process // + 4 cycles
 966:	fcad                	bnez	s1,8e0 <bit_process>

00000968 <se0_complete>:

.balign 4
se0_complete:
	// This is triggered when we finished getting a packet.
	andi a0, s1, 7; // Make sure we received an even number of bytes.
 968:	0074f513          	andi	a0,s1,7
	c.bnez a0, done_usb_message
 96c:	e159                	bnez	a0,9f2 <done_usb_message>


	// Special: handle ACKs?
	// Now we have to decide what we're doing based on the
	// packet type.
	addi  a1, sp, DATA_PTR_OFFSET
 96e:	03f10593          	addi	a1,sp,63
 972:	2188                	.short	0x2188
	XW_C_LBU(a0, a1, 0);	//lbu  a0, 0(a1)
	c.addi a1, 1
 974:	0585                	addi	a1,a1,1
	// 1001 => 10010110 => PID IN
	// 0001 => 10000111 => PID_OUT
	// 1101 => 10110100 => SETUP    (OK)

	// a0 contains first 4 bytes.
	la ra, done_usb_message_in // Common return address for all function calls.
 976:	00000097          	auipc	ra,0x0
 97a:	07c08093          	addi	ra,ra,124 # 9f2 <done_usb_message>

	// For ACK don't worry about CRC.
	addi a5, a0, -0b01001011
 97e:	fb550793          	addi	a5,a0,-75

	RESTORE_DEBUG_MARKER(48) // restore x4 for whatever in C land.
 982:	5242                	lw	tp,48(sp)

	la a4, rv003usb_internal_data
 984:	1ffff717          	auipc	a4,0x1ffff
 988:	69470713          	addi	a4,a4,1684 # 20000018 <rv003usb_internal_data>

	// ACK doesn't need good CRC.
	c.beqz a5, usb_pid_handle_ack
 98c:	00079463          	bnez	a5,994 <se0_complete+0x2c>
 990:	e21ff06f          	j	7b0 <usb_pid_handle_ack>

	// Next, check for tokens.
	c.bnez a3, crc_for_tokens_would_be_bad_maybe_data
 994:	ea9d                	bnez	a3,9ca <crc_for_tokens_would_be_bad_maybe_data>

00000996 <may_be_a_token>:
 996:	2192                	.short	0x2192
may_be_a_token:
	// Our CRC is 0, so we might be a token.

	// Do token-y things.
	XW_C_LHU( a2, a1, 0 )
	andi a0, a2, 0x7f // addr
 998:	07f67513          	andi	a0,a2,127
	c.srli a2, 7
 99c:	821d                	srli	a2,a2,0x7
	c.andi a2, 0xf    // endp
 99e:	8a3d                	andi	a2,a2,15
	li s0, ENDPOINTS
 9a0:	4411                	li	s0,4
	bgeu a2, s0, done_usb_message // Make sure < ENDPOINTS
 9a2:	04867863          	bgeu	a2,s0,9f2 <done_usb_message>
	c.beqz a0,  yes_check_tokens
 9a6:	c501                	beqz	a0,9ae <yes_check_tokens>
 9a8:	3300                	.short	0x3300
	// Otherwise, we might have our assigned address.
	XW_C_LBU(s0, a4, MY_ADDRESS_OFFSET_BYTES);	//	lbu s0, MY_ADDRESS_OFFSET_BYTES(a4)
	bne s0, a0, done_usb_message // addr != 0 && addr != ours.
 9aa:	04a41463          	bne	s0,a0,9f2 <done_usb_message>

000009ae <yes_check_tokens>:
yes_check_tokens:
	addi a5, a5, (0b01001011-0b10000111)
 9ae:	fc478793          	addi	a5,a5,-60 # 40010fc4 <__global_pointer$+0x200107c4>
	c.beqz a5, usb_pid_handle_out
 9b2:	cba5                	beqz	a5,a22 <usb_pid_handle_out>
	c.addi a5, (0b10000111-0b10010110)
 9b4:	17c5                	addi	a5,a5,-15
	c.beqz a5, usb_pid_handle_in
 9b6:	00079463          	bnez	a5,9be <yes_check_tokens+0x10>
 9ba:	b67ff06f          	j	520 <usb_pid_handle_in>
	c.addi a5, (0b10010110-0b10110100)
 9be:	1789                	addi	a5,a5,-30
	c.beqz a5, usb_pid_handle_setup
 9c0:	00079463          	bnez	a5,9c8 <yes_check_tokens+0x1a>
 9c4:	e0dff06f          	j	7d0 <usb_pid_handle_setup>

	c.j done_usb_message_in
 9c8:	a02d                	j	9f2 <done_usb_message>

000009ca <crc_for_tokens_would_be_bad_maybe_data>:

	// CRC is nonzero. (Good for Data packets)
crc_for_tokens_would_be_bad_maybe_data:
	li s0, 0xb001  // UGH: You can't use the CRC16 in reverse :(
 9ca:	642d                	lui	s0,0xb
 9cc:	0405                	addi	s0,s0,1 # b001 <rv003usb.c.084415bf+0x7d4f>
	c.sub a3, s0
 9ce:	8e81                	sub	a3,a3,s0
	c.bnez a3, done_usb_message_in
 9d0:	e28d                	bnez	a3,9f2 <done_usb_message>
	// Good CRC!!
	sub a3, t2, a1 //a3 = # of bytes read..
 9d2:	40b386b3          	sub	a3,t2,a1
	c.addi a3, 1
 9d6:	0685                	addi	a3,a3,1
	addi a5, a5, (0b01001011-0b11000011)
 9d8:	f8878793          	addi	a5,a5,-120
	c.li a2, 0
 9dc:	4601                	li	a2,0
	c.beqz a5, usb_pid_handle_data
 9de:	00079463          	bnez	a5,9e6 <crc_for_tokens_would_be_bad_maybe_data+0x1c>
 9e2:	c4fff06f          	j	630 <usb_pid_handle_data>
	c.addi a5, (0b11000011-0b11010010)
 9e6:	17c5                	addi	a5,a5,-15
	c.li a2, 1
 9e8:	4605                	li	a2,1
	c.beqz a5, usb_pid_handle_data
 9ea:	00079463          	bnez	a5,9f2 <done_usb_message>
 9ee:	c43ff06f          	j	630 <usb_pid_handle_data>

000009f2 <done_usb_message>:

done_usb_message:
done_usb_message_in:
	lw	s0, 24(sp)
 9f2:	4462                	lw	s0,24(sp)
	lw	s1, 28(sp)
 9f4:	44f2                	lw	s1,28(sp)
	lw	t0, 32(sp)
 9f6:	5282                	lw	t0,32(sp)
	lw	t1, 36(sp)
 9f8:	5312                	lw	t1,36(sp)
	lw	t2, 40(sp)
 9fa:	53a2                	lw	t2,40(sp)
	lw  ra, 52(sp)
 9fc:	50d2                	lw	ra,52(sp)

000009fe <ret_from_se0>:
another_interrupt_handler:
	RV003_ADD_EXTI_HANDLER
#endif

ret_from_se0:
	lw	s1, 28(sp)
 9fe:	44f2                	lw	s1,28(sp)
	RESTORE_DEBUG_MARKER(48)
 a00:	5242                	lw	tp,48(sp)
	lw	a2, 8(sp)
 a02:	4622                	lw	a2,8(sp)
	lw	a3, 12(sp)
 a04:	46b2                	lw	a3,12(sp)
	lw	a4, 16(sp)
 a06:	4742                	lw	a4,16(sp)
	lw	a1, 4(sp)
 a08:	4592                	lw	a1,4(sp)

00000a0a <interrupt_complete>:

interrupt_complete:
	// Acknowledge interrupt.
	// EXTI->INTFR = 1<<4
	c.j 1f; 1: // Extra little bit of delay to make sure we don't accidentally false fire.
 a0a:	a009                	j	a0c <interrupt_complete+0x2>

	la a5, EXTI_BASE + 20
 a0c:	400107b7          	lui	a5,0x40010
 a10:	41478793          	addi	a5,a5,1044 # 40010414 <__global_pointer$+0x2000fc14>
#ifdef RV003_ADD_EXTI_MASK
	li a0, (RV003_ADD_EXTI_MASK|(1<<USB_PIN_DM))
#else
	li a0, (1<<USB_PIN_DM)
 a14:	4541                	li	a0,16
#endif
	sw a0, 0(a5)
 a16:	c388                	sw	a0,0(a5)
	
	// Restore stack.
	lw	a0, 0(sp)
 a18:	4502                	lw	a0,0(sp)
	lw	a5, 20(sp)
 a1a:	47d2                	lw	a5,20(sp)
	addi	sp,sp,80
 a1c:	6161                	addi	sp,sp,80
	mret
 a1e:	30200073          	mret

00000a22 <usb_pid_handle_out>:
 a22:	a310                	.short	0xa310
//This will correctly swap back the endpoint.
usb_pid_handle_out:
	//void usb_pid_handle_out( uint32_t addr, uint8_t * data, uint32_t endp, uint32_t unused, struct rv003usb_internal * ist )	
	//sb a2, 0(a4) //ist->current_endpoint = endp;
	XW_C_SB( a2, a4, 0 ); // current_endpoint = endp
	c.j done_usb_message_in
 a24:	b7f9                	j	9f2 <done_usb_message>

00000a26 <handle_se0_keepalive>:

handle_se0_keepalive:
	// In here, we want to do smart stuff with the
	// 1ms tick.

	la  a0, SYSTICK_CNT
 a26:	e000f537          	lui	a0,0xe000f
 a2a:	0521                	addi	a0,a0,8 # e000f008 <__global_pointer$+0xc000e808>
	la a4, rv003usb_internal_data
 a2c:	1ffff717          	auipc	a4,0x1ffff
 a30:	5ec70713          	addi	a4,a4,1516 # 20000018 <rv003usb_internal_data>
	c.lw a1, LAST_SE0_OFFSET(a4) //last cycle count   last_se0_cyccount
 a34:	434c                	lw	a1,4(a4)
	c.lw a2, 0(a0) //this cycle count
 a36:	4110                	lw	a2,0(a0)
	c.sw a2, LAST_SE0_OFFSET(a4) //store it back to last_se0_cyccount
 a38:	c350                	sw	a2,4(a4)
	c.sub a2, a1
 a3a:	8e0d                	sub	a2,a2,a1
	c.sw a2, DELTA_SE0_OFFSET(a4) //record delta_se0_cyccount
 a3c:	c710                	sw	a2,8(a4)

	li a1, 48000
 a3e:	65b1                	lui	a1,0xc
 a40:	b8058593          	addi	a1,a1,-1152 # bb80 <rv003usb.c.084415bf+0x88ce>
	c.sub a2, a1
 a44:	8e0d                	sub	a2,a2,a1
	// This is our deviance from 48MHz.

	// Make sure we aren't in left field.
	li a5, 4000
 a46:	6785                	lui	a5,0x1
 a48:	fa078793          	addi	a5,a5,-96 # fa0 <_data_lma+0x2e4>
	bge a2, a5, ret_from_se0
 a4c:	faf659e3          	bge	a2,a5,9fe <ret_from_se0>
	li a5, -4000
 a50:	77fd                	lui	a5,0xfffff
 a52:	06078793          	addi	a5,a5,96 # fffff060 <__global_pointer$+0xdfffe860>
	blt a2, a5, ret_from_se0
 a56:	faf644e3          	blt	a2,a5,9fe <ret_from_se0>

	c.lw a1, SE0_WINDUP_OFFSET(a4) // load windup se0_windup
 a5a:	474c                	lw	a1,12(a4)
	c.add a1, a2
 a5c:	95b2                	add	a1,a1,a2
	c.sw a1, SE0_WINDUP_OFFSET(a4) // save windup
 a5e:	c74c                	sw	a1,12(a4)

	// No further adjustments
	beqz a1, ret_from_se0
 a60:	ddd9                	beqz	a1,9fe <ret_from_se0>

	// 0x40021000 = RCC.CTLR
	la a4, 0x40021000
 a62:	40021737          	lui	a4,0x40021
	lw a0, 0(a4)
 a66:	4308                	lw	a0,0(a4)
	srli a2, a0, 3 // Extract HSI Trim.
 a68:	00355613          	srli	a2,a0,0x3
	andi a2, a2, 0b11111
 a6c:	8a7d                	andi	a2,a2,31
	li a5, 0xffffff07  
 a6e:	f0700793          	li	a5,-249
	and a0, a0, a5	// Mask off non-HSI
 a72:	8d7d                	and	a0,a0,a5

	// Decimate windup - use as HSIrim.
	neg a1, a1
 a74:	40b005b3          	neg	a1,a1
	srai a2, a1, 9
 a78:	4095d613          	srai	a2,a1,0x9
	addi a2, a2, 16  // add HSI offset.
 a7c:	0641                	addi	a2,a2,16

	// Put trim in place in register.
	slli a2, a2, 3
 a7e:	060e                	slli	a2,a2,0x3
	or a0, a0, a2
 a80:	8d51                	or	a0,a0,a2
	sw a0, 0(a4)
 a82:	c308                	sw	a0,0(a4)

	j ret_from_se0
 a84:	bfad                	j	9fe <ret_from_se0>
 a86:	0001                	nop

00000a88 <usb_send_empty>:


.balign 4
//void usb_send_empty( uint32_t token );
usb_send_empty:
	c.mv a3, a0
 a88:	86aa                	mv	a3,a0
	la a0, always0
 a8a:	00000517          	auipc	a0,0x0
 a8e:	13650513          	addi	a0,a0,310 # bc0 <always0>
	li a1, 2
 a92:	4589                	li	a1,2
	c.mv a2, a1
 a94:	862e                	mv	a2,a1

00000a96 <usb_send_data>:
//void usb_send_data( uint8_t * data, uint32_t length, uint32_t poly_function, uint32_t token );
usb_send_data:
	addi	sp,sp,-16
 a96:	1141                	addi	sp,sp,-16
	sw	s0, 0(sp)
 a98:	c022                	sw	s0,0(sp)
	sw	s1, 4(sp)
 a9a:	c226                	sw	s1,4(sp)

	la a5, USB_GPIO_BASE
 a9c:	400117b7          	lui	a5,0x40011

	// ASAP: Turn the bus around and send our preamble + token.
	c.lw a4, CFGLR_OFFSET(a5)
 aa0:	4398                	lw	a4,0(a5)

	li s1, ~((0b1111<<(USB_PIN_DP*4)) | (0b1111<<(USB_PIN_DM*4)))
 aa2:	fff014b7          	lui	s1,0xfff01
 aa6:	14fd                	addi	s1,s1,-1 # fff00fff <__global_pointer$+0xdff007ff>
	and a4, s1, a4
 aa8:	8f65                	and	a4,a4,s1

	// Convert D+/D- into 2MHz outputs
	li s1, ((0b0010<<(USB_PIN_DP*4)) | (0b0010<<(USB_PIN_DM*4)))
 aaa:	000224b7          	lui	s1,0x22
	or a4, s1, a4
 aae:	8f45                	or	a4,a4,s1

	li s1, (1<<USB_PIN_DP) | (1<<(USB_PIN_DM+16))
 ab0:	001004b7          	lui	s1,0x100
 ab4:	04a1                	addi	s1,s1,8 # 100008 <rv003usb.c.084415bf+0xfcd56>
	c.sw s1, BSHR_OFFSET(a5)
 ab6:	cb84                	sw	s1,16(a5)

	//00: Universal push-pull output mode
	c.sw a4, CFGLR_OFFSET(a5)
 ab8:	c398                	sw	a4,0(a5)

	li t1, (1<<USB_PIN_DP) | (1<<(USB_PIN_DM+16)) | (1<<USB_PIN_DM) | (1<<(USB_PIN_DP+16));
 aba:	00180337          	lui	t1,0x180
 abe:	0361                	addi	t1,t1,24 # 180018 <rv003usb.c.084415bf+0x17cd66>

	SAVE_DEBUG_MARKER( 8 )
 ac0:	c412                	sw	tp,8(sp)

	// Save off our preamble and token.
	c.slli a3, 7     //Put token further up so it gets sent later.
 ac2:	069e                	slli	a3,a3,0x7
	ori s0, a3, 0x40  
 ac4:	0406e413          	ori	s0,a3,64

	li t0, 0x0000
 ac8:	4281                	li	t0,0
	c.bnez a2, done_poly_check
 aca:	e609                	bnez	a2,ad4 <done_poly_check>
	li t0, 0xa001
 acc:	62a9                	lui	t0,0xa
 ace:	0285                	addi	t0,t0,1 # a001 <rv003usb.c.084415bf+0x6d4f>
	li a2, 0xffff
 ad0:	6641                	lui	a2,0x10
 ad2:	167d                	addi	a2,a2,-1 # ffff <rv003usb.c.084415bf+0xcd4d>

00000ad4 <done_poly_check>:
done_poly_check:

	c.slli a1, 3 // bump up one extra to be # of bits
 ad4:	058e                	slli	a1,a1,0x3
	mv t2, a1
 ad6:	83ae                	mv	t2,a1

	// t0 is our polynomial
	// a2 is our running CRC.
	// a3 is our token.
	DEBUG_TICK_SETUP
 ad8:	40013237          	lui	tp,0x40013
 adc:	c5820213          	addi	tp,tp,-936 # 40012c58 <__global_pointer$+0x20012458>

	c.li a4, 6 // reset bit stuffing.
 ae0:	4719                	li	a4,6
	c.li a1, 15 // 15 bits.
 ae2:	45bd                	li	a1,15

	//c.nop; c.nop; c.nop;
	c.j pre_and_tok_send_inner_loop
 ae4:	a011                	j	ae8 <pre_and_tok_send_inner_loop>
 ae6:	0001                	nop

00000ae8 <pre_and_tok_send_inner_loop>:
		* We have to decrement our bit stuffing index.
		* If it is 0, we can reset our bit stuffing index.
	*/

	// a3 is now the lsb of s0 (the 'next bit' to read out)
	c.mv a3, s0
 ae8:	86a2                	mv	a3,s0
	c.srli s0, 1 // Shift down into the next bit.
 aea:	8005                	srli	s0,s0,0x1
	c.andi a3, 1
 aec:	8a85                	andi	a3,a3,1
	// If a3 is 0, we should FLIP
	// if a3 is 1, we should NOT flip.

	c.addi a4, -1
 aee:	177d                	addi	a4,a4,-1 # 40020fff <__global_pointer$+0x200207ff>
	c.bnez a3, pre_and_tok_send_one_bit
 af0:	e681                	bnez	a3,af8 <pre_and_tok_send_one_bit>
//Send 0 bit. (Flip)
	// Flip s1 (our bshr setting) by xoring it.
	// 10.....01
	// 11.....11 (xor with)
	// 01.....10
	xor s1, s1, t1
 af2:	0064c4b3          	xor	s1,s1,t1
	c.li a4, 6 // reset bit stuffing.
 af6:	4719                	li	a4,6

00000af8 <pre_and_tok_send_one_bit>:
	// DO NOT flip.  Allow a4 to increment.
// Deliberately unaligned for timing purposes.
.balign 4
pre_and_tok_send_one_bit:
	sw s1, BSHR_OFFSET(a5)
 af8:	cb84                	sw	s1,16(a5)
	//Bit stuffing doesn't happen.
	c.addi a1, -1
 afa:	15fd                	addi	a1,a1,-1
	c.beqz a1, pre_and_tok_done_sending_data
 afc:	c591                	beqz	a1,b08 <pre_and_tok_done_sending_data>
	nx6p3delay( 2, a3 );	c.nop;             // Free time!
 afe:	468d                	li	a3,3
 b00:	16fd                	addi	a3,a3,-1
 b02:	fefd                	bnez	a3,b00 <pre_and_tok_send_one_bit+0x8>
 b04:	0001                	nop
	c.j pre_and_tok_send_inner_loop
 b06:	b7cd                	j	ae8 <pre_and_tok_send_inner_loop>

00000b08 <pre_and_tok_done_sending_data>:
////////////////////////////////////////////////////////////////////////////

	// We have very little time here.  Just enough to do this.

	//Restore size.
	mv a1, t2//lw  a1, 12(sp)
 b08:	859e                	mv	a1,t2
	c.beqz a1, no_really_done_sending_data  //No actual payload?  Bail!
 b0a:	c5ad                	beqz	a1,b74 <no_really_done_sending_data>
	c.addi a1, -1
 b0c:	15fd                	addi	a1,a1,-1
//	beqz t2, no_really_done_sending_data 

	bnez t0, done_poly_check2
 b0e:	00029463          	bnez	t0,b16 <done_poly_check2>
	li a2, 0xffff
 b12:	6641                	lui	a2,0x10
 b14:	167d                	addi	a2,a2,-1 # ffff <rv003usb.c.084415bf+0xcd4d>

00000b16 <done_poly_check2>:
 b16:	0001                	nop

00000b18 <load_next_byte>:
 b18:	2100                	.short	0x2100
	// CH32v003 has the XW extension.
	// this replaces: lb s0, 0(a0)
	XW_C_LBU(s0, a0, 0);
	//lb s0, 0(a0)
	//	.long 0x00150513 // addi a0, a0, 1  (For alignment's sake)
	c.addi a0, 1
 b1a:	0505                	addi	a0,a0,1

00000b1c <send_inner_loop>:
		* We have to decrement our bit stuffing index.
		* If it is 0, we can reset our bit stuffing index.
	*/

	// a3 is now the lsb of s0 (the 'next bit' to read out)
	c.mv a3, s0
 b1c:	86a2                	mv	a3,s0
	c.andi a3, 1
 b1e:	8a85                	andi	a3,a3,1
	// If a3 is 0, we should FLIP
	// if a3 is 1, we should NOT flip.
	c.beqz a3, send_zero_bit
 b20:	ce81                	beqz	a3,b38 <send_zero_bit>
	c.srli s0, 1 // Shift down into the next bit.
 b22:	8005                	srli	s0,s0,0x1
//send_one_bit:
	//HANDLE_CRC (1 bit)
	andi a3, a2, 1
 b24:	00167693          	andi	a3,a2,1
	c.addi a3, -1
 b28:	16fd                	addi	a3,a3,-1
	and a3, a3, t0
 b2a:	0056f6b3          	and	a3,a3,t0
	c.srli a2, 1
 b2e:	8205                	srli	a2,a2,0x1
	c.xor a2, a3
 b30:	8e35                	xor	a2,a2,a3

	c.addi a4, -1
 b32:	177d                	addi	a4,a4,-1
	c.beqz a4, insert_stuffed_bit
 b34:	cf25                	beqz	a4,bac <insert_stuffed_bit>
	c.j cont_after_jump
 b36:	a829                	j	b50 <cont_after_jump>

00000b38 <send_zero_bit>:
//Send 0 bit. (Flip)
.balign 4
send_zero_bit:
	c.srli s0, 1 // Shift down into the next bit.
 b38:	8005                	srli	s0,s0,0x1
	// a3 is temp
	// t0 is polynomial.

	// XXX WARNING: this was by https://github.com/cnlohr/rv003usb/issues/7 
	// TODO Check me!
	slli a3,a2,31 // Put a3s LSB into a0s MSB
 b3a:	01f61693          	slli	a3,a2,0x1f
	c.srai a3,31    // Copy MSB into all other bits
 b3e:	86fd                	srai	a3,a3,0x1f

	// Flip s1 (our bshr setting) by xoring it.
	// 10.....01
	// 11.....11 (xor with)
	// 01.....10
	xor s1, s1, t1
 b40:	0064c4b3          	xor	s1,s1,t1
	sw s1, BSHR_OFFSET(a5)
 b44:	cb84                	sw	s1,16(a5)

	c.li a4, 6 // reset bit stuffing.
 b46:	4719                	li	a4,6

	// XXX XXX CRC down here to make bit stuffing timings line up.
	c.srli a2,1
 b48:	8205                	srli	a2,a2,0x1
	and a3,a3,t0
 b4a:	0056f6b3          	and	a3,a3,t0
	c.xor  a2,a3 
 b4e:	8e35                	xor	a2,a2,a3

00000b50 <cont_after_jump>:

.balign 4
cont_after_jump:
send_end_bit_complete:
	c.beqz a1, done_sending_data
 b50:	c981                	beqz	a1,b60 <done_sending_data>
	andi a3, a1, 7
 b52:	0075f693          	andi	a3,a1,7
	c.addi a1, -1
 b56:	15fd                	addi	a1,a1,-1
	c.beqz a3, load_next_byte
 b58:	d2e1                	beqz	a3,b18 <load_next_byte>
	// Wait an extra few cycles.
	c.j 1f; 1:
 b5a:	a009                	j	b5c <cont_after_jump+0xc>
	c.j send_inner_loop
 b5c:	b7c1                	j	b1c <send_inner_loop>
 b5e:	0001                	nop

00000b60 <done_sending_data>:

.balign 4
done_sending_data:
	// BUT WAIT!! MAYBE WE NEED TO CRC!
	beqz t0, no_really_done_sending_data
 b60:	00028a63          	beqz	t0,b74 <no_really_done_sending_data>
	srli t0, t0, 8 // reset poly - we don't want it anymore.
 b64:	0082d293          	srli	t0,t0,0x8
	li a1, 7 // Load 8 more bits out
 b68:	459d                	li	a1,7
	beqz t0, send_inner_loop  //Second CRC byte
 b6a:	fa0289e3          	beqz	t0,b1c <send_inner_loop>
	// First CRC byte
	not s0, a2 // get read to send out the CRC.
 b6e:	fff64413          	not	s0,a2
	c.j send_inner_loop
 b72:	b76d                	j	b1c <send_inner_loop>

00000b74 <no_really_done_sending_data>:
.balign 4
no_really_done_sending_data:

//	c.bnez a2, poly_function  TODO: Uncomment me!

	nx6p3delay( 2, a3 );
 b74:	468d                	li	a3,3
 b76:	16fd                	addi	a3,a3,-1
 b78:	fefd                	bnez	a3,b76 <no_really_done_sending_data+0x2>

	// Need to perform an SE0.
	li s1, (1<<(USB_PIN_DM+16)) | (1<<(USB_PIN_DP+16))
 b7a:	001804b7          	lui	s1,0x180
	c.sw s1, BSHR_OFFSET(a5)
 b7e:	cb84                	sw	s1,16(a5)

	nx6p3delay( 7, a3 );
 b80:	46a1                	li	a3,8
 b82:	16fd                	addi	a3,a3,-1
 b84:	fefd                	bnez	a3,b82 <no_really_done_sending_data+0xe>

	li s1, (1<<(USB_PIN_DM)) | (1<<(USB_PIN_DP+16))
 b86:	000804b7          	lui	s1,0x80
 b8a:	04c1                	addi	s1,s1,16 # 80010 <rv003usb.c.084415bf+0x7cd5e>
	c.sw s1, BSHR_OFFSET(a5)
 b8c:	cb84                	sw	s1,16(a5)

	lw s1, CFGLR_OFFSET(a5)
 b8e:	4384                	lw	s1,0(a5)
	// Convert D+/D- into inputs.
	li a3, ~((0b11<<(USB_PIN_DP*4)) | (0b11<<(USB_PIN_DM*4)))
 b90:	fffcd6b7          	lui	a3,0xfffcd
 b94:	16fd                	addi	a3,a3,-1 # fffccfff <__global_pointer$+0xdffcc7ff>
	and s1, a3, s1
 b96:	8cf5                	and	s1,s1,a3
	// 01: Floating input mode.
	li a3, ((0b01<<(USB_PIN_DP*4+2)) | (0b01<<(USB_PIN_DM*4+2)))
 b98:	000446b7          	lui	a3,0x44
	or s1, a3, s1
 b9c:	8cd5                	or	s1,s1,a3
	sw s1, CFGLR_OFFSET(a5)
 b9e:	c384                	sw	s1,0(a5)

	lw	s0, 0(sp)
 ba0:	4402                	lw	s0,0(sp)
	lw	s1, 4(sp)
 ba2:	4492                	lw	s1,4(sp)
	RESTORE_DEBUG_MARKER( 8 )
 ba4:	4222                	lw	tp,8(sp)
	addi	sp,sp,16
 ba6:	0141                	addi	sp,sp,16
	ret
 ba8:	8082                	ret
 baa:	0001                	nop

00000bac <insert_stuffed_bit>:

.balign 4
// TODO: This seems to be either 222 or 226 (not 224) in cases.
// It's off by 2 clock cycles.  Probably OK, but, hmm.
insert_stuffed_bit:
	nx6p3delay(3, a3)
 bac:	4691                	li	a3,4
 bae:	16fd                	addi	a3,a3,-1 # 43fff <rv003usb.c.084415bf+0x40d4d>
 bb0:	fefd                	bnez	a3,bae <insert_stuffed_bit+0x2>
	xor s1, s1, t1
 bb2:	0064c4b3          	xor	s1,s1,t1
	c.li a4, 6 // reset bit stuffing.
 bb6:	4719                	li	a4,6
	c.nop
 bb8:	0001                	nop
	c.nop
 bba:	0001                	nop
	sw s1, BSHR_OFFSET(a5)
 bbc:	cb84                	sw	s1,16(a5)
	c.j send_end_bit_complete
 bbe:	bf49                	j	b50 <cont_after_jump>

00000bc0 <always0>:
	...

00000bc8 <string3>:
 bc8:	030a 0030 0031 0030 0031 0000               ..0.1.0.1...

00000bd4 <string2>:
 bd4:	032a 0073 006f 0066 0074 0020 0075 0073     *.s.o.f.t. .u.s.
 be4:	0062 0020 0075 0061 0072 0074 0020 0062     b. .u.a.r.t. .b.
 bf4:	0072 0069 0064 0067 0065 0000               r.i.d.g.e...

00000c00 <string1>:
 c00:	0316 004b 0061 006e 006b 0065 006e 0036     ..K.a.n.k.e.n.6.
 c10:	0031 0037 0034 0000                         1.7.4...

00000c18 <string0>:
 c18:	0304 0409                                   ....

00000c1c <config_descriptor>:
 c1c:	0209 0043 0102 8000 0964 0004 0100 0202     ..C.....d.......
 c2c:	0001 2405 1000 0401 0224 0500 0624 0100     ...$....$...$...
 c3c:	2405 0201 0701 8105 0803 0100 0409 0001     .$..............
 c4c:	0a02 3200 0700 0205 0803 0100 0507 0383     ...2............
 c5c:	0008 0001                                   ....

00000c60 <device_descriptor>:
 c60:	0112 0110 02fe 0800 55f0 7e54 0110 0201     .........UT~....
 c70:	0103 0000                                   ....

00000c74 <descriptor_list>:
 c74:	0100 0000 0c60 0000 0012 0000 0200 0000     ....`...........
 c84:	0c1c 0000 0043 0000 0300 0000 0c18 0000     ....C...........
 c94:	0004 0000 0301 0409 0c00 0000 0016 0000     ................
 ca4:	0302 0409 0bd4 0000 002a 0000 0303 0409     ........*.......
 cb4:	0bc8 0000 000a 0000                         ........
